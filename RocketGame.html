<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbit Insertion Challenge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
        }
        
        #canvas {
            background: #000;
        }
        
        #game-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 5px;
            width: 260px;
            z-index: 100;
        }
        
        #game-panel h2 {
            color: #0ff;
            margin-bottom: 10px;
            border-bottom: 2px solid #0ff;
            padding-bottom: 8px;
            text-align: center;
            font-size: 14px;
        }
        
        .mission-brief {
            color: #ff0;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 0, 0.1);
            border-left: 2px solid #ff0;
            font-size: 11px;
        }
        
        .target-orbit {
            color: #0f0;
            margin: 8px 0;
            padding: 6px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
        }
        
        .target-orbit .label {
            color: #888;
            display: inline-block;
            width: 110px;
            font-size: 11px;
        }
        
        .target-orbit .value {
            color: #0ff;
            font-weight: bold;
            font-size: 11px;
        }
        
        .current-status {
            margin: 8px 0;
            padding: 6px;
            font-size: 11px;
        }
        
        .current-status .label {
            color: #888;
            display: inline-block;
            width: 110px;
        }
        
        .current-status .value {
            color: #0f0;
        }
        
        .current-status .value.success {
            color: #0f0;
        }
        
        .current-status .value.warning {
            color: #ff0;
        }
        
        .current-status .value.fail {
            color: #f00;
        }
        
        #pitch-controls {
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 2px solid #0f0;
            border-radius: 5px;
            width: 200px;
            z-index: 100;
        }
        
        #pitch-controls h3 {
            color: #0ff;
            margin-bottom: 8px;
            text-align: center;
            font-size: 12px;
        }
        
        .pitch-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .pitch-buttons button {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .pitch-buttons button:hover {
            background: #0f0;
            color: #000;
        }
        
        .pitch-buttons button:active {
            background: #0ff;
            color: #000;
        }
        
        .pitch-display {
            text-align: center;
            font-size: 20px;
            color: #0ff;
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
        }
        
        #score-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0f0;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 2px solid #0ff;
            border-radius: 5px;
            width: 200px;
            z-index: 100;
        }
        
        #score-panel h3 {
            color: #0ff;
            margin-bottom: 8px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 4px;
            font-size: 12px;
        }
        
        .score-item {
            margin: 5px 0;
            padding: 3px 0;
            font-size: 10px;
        }
        
        .score-item .label {
            color: #888;
            display: inline-block;
            width: 120px;
        }
        
        .score-item .value {
            color: #0f0;
            float: right;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        #orbital-view {
            position: fixed;
            bottom: 280px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 2px solid #0ff;
            border-radius: 5px;
            width: 200px;
            z-index: 100;
        }
        
        #orbital-view h3 {
            color: #0ff;
            margin-bottom: 8px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        #orbital-canvas {
            width: 100%;
            height: 180px;
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
        }
        
        .orbital-info {
            margin-top: 8px;
            font-size: 9px;
            color: #888;
        }
        
        .orbital-info .label {
            display: inline-block;
            width: 80px;
            color: #888;
        }
        
        .orbital-info .value {
            color: #0f0;
        }
        
        #guidance-panel {
            position: fixed;
            bottom: 280px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 2px solid #ff0;
            border-radius: 5px;
            width: 260px;
            z-index: 100;
        }
        
        #guidance-panel h3 {
            color: #ff0;
            margin-bottom: 8px;
            border-bottom: 1px solid #ff0;
            padding-bottom: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .guidance-item {
            margin: 6px 0;
            padding: 4px 0;
            font-size: 11px;
        }
        
        .guidance-item .label {
            color: #888;
            display: inline-block;
            width: 140px;
        }
        
        .guidance-item .value {
            color: #0f0;
            float: right;
            font-weight: bold;
        }
        
        .guidance-item .value.good {
            color: #0f0;
        }
        
        .guidance-item .value.warning {
            color: #ff0;
        }
        
        .guidance-item .value.bad {
            color: #f00;
        }
        
        .guidance-hint {
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 255, 0, 0.1);
            border-left: 3px solid #ff0;
            font-size: 10px;
            color: #ff0;
            line-height: 1.4;
        }
        
        .pitch-guidance {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
        }
        
        .pitch-guidance .recommended {
            font-size: 20px;
            color: #0ff;
            font-weight: bold;
        }
        
        .pitch-guidance .direction {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }
        
        .pitch-guidance .direction.up {
            color: #0f0;
        }
        
        .pitch-guidance .direction.down {
            color: #f00;
        }
        
        #telemetry {
            position: fixed;
            top: 20px;
            left: 300px;
            color: #0f0;
            font-size: 11px;
            line-height: 1.4;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border: 1px solid #0f0;
            border-radius: 5px;
            width: 220px;
            z-index: 100;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        #telemetry h3 {
            color: #0ff;
            margin-bottom: 8px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 4px;
            font-size: 12px;
        }
        
        .telemetry-section {
            margin: 6px 0;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        
        .telemetry-section .label {
            color: #888;
            display: inline-block;
            width: 95px;
            font-size: 10px;
        }
        
        .telemetry-section .value {
            color: #0f0;
            float: right;
            font-size: 10px;
        }
        
        button {
            background: #222;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #victory-overlay, #failure-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        #victory-overlay h1 {
            color: #0f0;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0f0;
        }
        
        #failure-overlay h1 {
            color: #f00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #f00;
        }
        
        .overlay-content {
            text-align: center;
            color: #fff;
            font-size: 20px;
            margin-bottom: 30px;
        }
        
        .overlay-score {
            color: #0ff;
            font-size: 24px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="game-panel">
        <h2>ORBIT INSERTION CHALLENGE</h2>
        <div class="mission-brief">
            <strong>MISSION:</strong> Manually control your pitch to insert into the target orbit. Use W/S or the buttons to adjust pitch during flight.
        </div>
        <div class="target-orbit">
            <div><span class="label">Target Altitude:</span> <span class="value" id="target-alt">400 km</span></div>
            <div><span class="label">Tolerance:</span> <span class="value" id="target-tol">Â±50 km</span></div>
            <div><span class="label">Max Eccentricity:</span> <span class="value" id="target-ecc">0.1</span></div>
        </div>
        <div class="current-status">
            <div><span class="label">Status:</span> <span class="value" id="mission-status">READY</span></div>
            <div><span class="label">Altitude:</span> <span class="value" id="current-alt">0 km</span></div>
            <div><span class="label">Eccentricity:</span> <span class="value" id="current-ecc">-</span></div>
            <div><span class="label">Match:</span> <span class="value" id="match-status">-</span></div>
        </div>
    </div>
    
    <div id="telemetry">
        <h3>TELEMETRY</h3>
        <div class="telemetry-section">
            <div><span class="label">T+</span><span class="value" id="time">00:00:00</span></div>
            <div><span class="label">Stage</span><span class="value" id="stage">1</span></div>
        </div>
        <div class="telemetry-section">
            <div><span class="label">Altitude</span><span class="value" id="altitude">0 km</span></div>
            <div><span class="label">Downrange</span><span class="value" id="downrange">0 km</span></div>
            <div><span class="label">Velocity</span><span class="value" id="velocity">0 m/s</span></div>
            <div><span class="label">Vertical V</span><span class="value" id="vvel">0 m/s</span></div>
            <div><span class="label">Horizontal V</span><span class="value" id="hvel">0 m/s</span></div>
        </div>
        <div class="telemetry-section">
            <div><span class="label">Acceleration</span><span class="value" id="accel">0 G</span></div>
            <div><span class="label">Max Q</span><span class="value" id="maxq">0 kPa</span></div>
            <div><span class="label">Dynamic Press</span><span class="value" id="dynpress">0 kPa</span></div>
        </div>
        <div class="telemetry-section">
            <div><span class="label">Mass</span><span class="value" id="mass">0 kg</span></div>
            <div><span class="label">Propellant</span><span class="value" id="propellant">0%</span></div>
            <div><span class="label">Thrust</span><span class="value" id="thrust">0 kN</span></div>
        </div>
        <div class="telemetry-section">
            <div><span class="label">Pitch</span><span class="value" id="pitch">90Â°</span></div>
            <div><span class="label">Apoapsis</span><span class="value" id="apoapsis">0 km</span></div>
            <div><span class="label">Periapsis</span><span class="value" id="periapsis">0 km</span></div>
        </div>
    </div>
    
    <div id="score-panel">
        <h3>SCORE</h3>
        <div class="score-item">
            <span class="label">Altitude Score:</span>
            <span class="value" id="alt-score">0</span>
        </div>
        <div class="score-item">
            <span class="label">Orbit Quality:</span>
            <span class="value" id="orbit-score">0</span>
        </div>
        <div class="score-item">
            <span class="label">Fuel Bonus:</span>
            <span class="value" id="fuel-score">0</span>
        </div>
        <div class="score-item" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
            <span class="label" style="color: #0ff; font-weight: bold;">TOTAL:</span>
            <span class="value" id="total-score" style="color: #0ff; font-weight: bold; font-size: 18px;">0</span>
        </div>
    </div>
    
    <div id="guidance-panel">
        <h3>ðŸŽ¯ GUIDANCE</h3>
        <div class="guidance-item">
            <span class="label">Trajectory:</span>
            <span class="value" id="trajectory-status">-</span>
        </div>
        <div class="guidance-item">
            <span class="label">Horiz Velocity:</span>
            <span class="value" id="horiz-velocity">-</span>
        </div>
        <div class="guidance-item">
            <span class="label">Target Orbital V:</span>
            <span class="value" id="target-orbital-v">-</span>
        </div>
        <div class="guidance-item">
            <span class="label">Velocity Deficit:</span>
            <span class="value" id="velocity-deficit">-</span>
        </div>
        <div class="guidance-item">
            <span class="label">Eccentricity:</span>
            <span class="value" id="guidance-ecc">-</span>
        </div>
        <div class="guidance-item">
            <span class="label">Throttle:</span>
            <span class="value" id="throttle-display">100%</span>
        </div>
        <div class="guidance-hint" id="guidance-hint">
            Guidance will appear during flight<br>
            â†‘â†“ Arrow keys to throttle
        </div>
    </div>
    
    <div id="pitch-controls">
        <h3>MANUAL PITCH CONTROL</h3>
        <div class="pitch-display" id="current-pitch-display">90Â°</div>
        <div class="pitch-guidance" id="pitch-guidance-display">
            <div class="direction" id="pitch-direction-hint">Adjust pitch during flight</div>
        </div>
        <div class="pitch-buttons">
            <button id="pitch-up-btn">â†‘ PITCH UP<br>(W Key)</button>
            <button id="pitch-down-btn">â†“ PITCH DOWN<br>(S Key)</button>
        </div>
        <div style="text-align: center; color: #888; font-size: 11px; margin-top: 10px;">
            Hold buttons or keys to adjust
        </div>
    </div>
    
    <div id="orbital-view">
        <h3>ORBITAL VIEW</h3>
        <canvas id="orbital-canvas"></canvas>
        <div class="orbital-info">
            <div><span class="label">Apoapsis:</span> <span class="value" id="orb-apo">-</span></div>
            <div><span class="label">Periapsis:</span> <span class="value" id="orb-peri">-</span></div>
            <div><span class="label">Eccentricity:</span> <span class="value" id="orb-ecc">-</span></div>
            <div><span class="label">Semi-major:</span> <span class="value" id="orb-sma">-</span></div>
        </div>
    </div>
    
    <div id="controls">
        <button id="launch-btn">LAUNCH</button>
        <button id="pause-btn" style="display: none;">PAUSE</button>
        <button id="reset-btn">RESET</button>
        <button id="speed-btn">1x</button>
        <button id="new-mission-btn">NEW MISSION</button>
    </div>
    
    <div id="victory-overlay">
        <h1>MISSION SUCCESS!</h1>
        <div class="overlay-content">You successfully inserted into the target orbit!</div>
        <div class="overlay-score" id="victory-score">Final Score: 0</div>
        <button id="victory-continue-btn" style="padding: 15px 40px; font-size: 16px;">CONTINUE</button>
    </div>
    
    <div id="failure-overlay">
        <h1>MISSION FAILED</h1>
        <div class="overlay-content" id="failure-reason">Reason will appear here</div>
        <div class="overlay-score" id="failure-score">Final Score: 0</div>
        <button id="failure-retry-btn" style="padding: 15px 40px; font-size: 16px;">RETRY</button>
    </div>

    <script>
        // Load the original simulation code
        // We'll embed it here but modify it for game mode
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const orbitalCanvas = document.getElementById('orbital-canvas');
        const orbitalCtx = orbitalCanvas.getContext('2d');
        
        function resizeOrbitalCanvas() {
            orbitalCanvas.width = orbitalCanvas.offsetWidth;
            orbitalCanvas.height = orbitalCanvas.offsetHeight;
        }
        resizeOrbitalCanvas();
        window.addEventListener('resize', resizeOrbitalCanvas);
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Physical constants
        const G = 6.67430e-11;
        const EARTH_MASS = 5.972e24;
        const EARTH_RADIUS = 6.371e6;
        const EARTH_ROTATION = 7.2921159e-5;
        const KARMAN_LINE = 100000;
        const ATM_SCALE_HEIGHT = 8500;
        const SEA_LEVEL_PRESSURE = 101325;
        const SEA_LEVEL_DENSITY = 1.225;
        
        // Rocket configuration (Falcon 9-like)
        const ROCKET_CONFIG = {
            stages: [
                {
                    name: "Stage 1",
                    dryMass: 22200,
                    propellantMass: 395700,
                    thrust: 7607000,
                    thrustVac: 8227000,
                    isp: 282,
                    ispVac: 311,
                    diameter: 3.7,
                    length: 47,
                    dragCoeff: 0.3
                },
                {
                    name: "Stage 2",
                    dryMass: 4000,
                    propellantMass: 92670,
                    thrust: 981000,
                    thrustVac: 981000,
                    isp: 348,
                    ispVac: 348,
                    diameter: 3.7,
                    length: 14,
                    dragCoeff: 0.25
                }
            ],
            payload: 15000,
            fairingMass: 1700,
            fairingJettisonAlt: 110000,
            totalLength: 70
        };
        
        // Game state
        let gameState = {
            targetAltitude: 400000, // meters (400 km)
            targetTolerance: 50000, // meters (Â±50 km)
            maxEccentricity: 0.1,
            missionComplete: false,
            missionFailed: false,
            score: {
                altitude: 0,
                orbit: 0,
                fuel: 0,
                total: 0
            },
            checkInterval: 0.5 // Check mission status every 0.5 seconds
        };
        
        // Manual pitch control
        let manualPitch = null; // null = use program, number = override pitch
        let pitchAdjustSpeed = 1.5; // degrees per second - realistic pitch rate
        
        // Pitch program (used as default/starting point)
        let PITCH_PROGRAM = [
            { time: 0, pitch: 90 },
            { time: 10, pitch: 90 },
            { time: 20, pitch: 80 },
            { time: 40, pitch: 68 },
            { time: 60, pitch: 55 },
            { time: 80, pitch: 43 },
            { time: 100, pitch: 33 },
            { time: 120, pitch: 25 },
            { time: 150, pitch: 17 },
            { time: 180, pitch: 11 },
            { time: 220, pitch: 6 },
            { time: 280, pitch: 3 },
            { time: 400, pitch: 0 },
            { time: 600, pitch: 0 }
        ];
        
        let state = {
            running: false,
            time: 0,
            timeWarp: 1,
            x: 0,
            y: EARTH_RADIUS,
            vx: 0,
            vy: 0,
            currentStage: 0,
            propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
            fairingJettisoned: false,
            maxQ: 0,
            events: [],
            apoapsis: 0,
            periapsis: 0,
            engineOn: false,
            throttle: 1.0, // 0.0 to 1.0 (0% to 100%)
            trail: [],
            manualZoom: 1.0,
            autoZoom: true,
            cameraMode: 'rocket',
            burnMode: null,
            burnStartTime: null
        };
        
        const LAUNCH_LATITUDE = 28.5 * Math.PI / 180;
        
        function generateNewMission() {
            // Generate random target orbit between 200-800 km
            gameState.targetAltitude = (200 + Math.random() * 600) * 1000; // meters
            gameState.targetTolerance = 50000; // Â±50 km standard
            gameState.maxEccentricity = 0.1;
            gameState.missionComplete = false;
            gameState.missionFailed = false;
            gameState.score = { altitude: 0, orbit: 0, fuel: 0, total: 0 };
            
            document.getElementById('target-alt').textContent = (gameState.targetAltitude / 1000).toFixed(0) + ' km';
            document.getElementById('target-tol').textContent = 'Â±' + (gameState.targetTolerance / 1000).toFixed(0) + ' km';
            document.getElementById('target-ecc').textContent = gameState.maxEccentricity.toFixed(2);
            document.getElementById('mission-status').textContent = 'READY';
            document.getElementById('mission-status').className = 'value';
            
            // Hide overlays
            document.getElementById('victory-overlay').style.display = 'none';
            document.getElementById('failure-overlay').style.display = 'none';
        }
        
        function initState() {
            // Initialize rocket at pad position
            const x0 = 0;
            const y0 = EARTH_RADIUS;
            
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Rocket should start with this velocity so airspeed is ~0
            // Earth rotates counterclockwise (eastward)
            const atmVx0 = EARTH_ROTATION * y0;  // perpendicular to position vector (eastward)
            const atmVy0 = -EARTH_ROTATION * x0;
            
            state = {
                running: false,
                time: 0,
                timeWarp: 1,
                x: x0,
                y: y0,
                vx: atmVx0,  // Match atmospheric velocity so airspeed is ~0
                vy: atmVy0,
                currentStage: 0,
                propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
                fairingJettisoned: false,
                maxQ: 0,
                events: [],
                apoapsis: 0,
                periapsis: 0,
                engineOn: false,
                throttle: 1.0,
                trail: [],
                manualZoom: 1.0,
                autoZoom: true,
                cameraMode: 'rocket',
                burnMode: null,
                burnStartTime: null
            };
            
            manualPitch = null;
            gameState.missionComplete = false;
            gameState.missionFailed = false;
        }
        
        function getTotalMass() {
            let mass = ROCKET_CONFIG.payload;
            if (!state.fairingJettisoned) mass += ROCKET_CONFIG.fairingMass;
            for (let i = state.currentStage; i < ROCKET_CONFIG.stages.length; i++) {
                mass += ROCKET_CONFIG.stages[i].dryMass + state.propellantRemaining[i];
            }
            return mass;
        }
        
        function getAltitude() {
            return Math.sqrt(state.x * state.x + state.y * state.y) - EARTH_RADIUS;
        }
        
        function getAtmosphericDensity(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_DENSITY * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getAtmosphericPressure(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_PRESSURE * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getGravity(r) {
            return G * EARTH_MASS / (r * r);
        }
        
        function getPitch(time) {
            // If manual pitch is set, use it; otherwise use program
            if (manualPitch !== null) {
                return Math.max(0, Math.min(90, manualPitch));
            }
            
            for (let i = 0; i < PITCH_PROGRAM.length - 1; i++) {
                if (time >= PITCH_PROGRAM[i].time && time < PITCH_PROGRAM[i + 1].time) {
                    const t = (time - PITCH_PROGRAM[i].time) / (PITCH_PROGRAM[i + 1].time - PITCH_PROGRAM[i].time);
                    return PITCH_PROGRAM[i].pitch + t * (PITCH_PROGRAM[i + 1].pitch - PITCH_PROGRAM[i].pitch);
                }
            }
            return PITCH_PROGRAM[PITCH_PROGRAM.length - 1].pitch;
        }
        
        function getCurrentThrust(altitude) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            const baseThrust = stage.thrust * pressureRatio + stage.thrustVac * (1 - pressureRatio);
            return baseThrust * state.throttle;
        }
        
        function getOrbitalVelocity(altitude) {
            // v = sqrt(GM/r) for circular orbit
            const r = EARTH_RADIUS + altitude;
            const mu = G * EARTH_MASS;
            return Math.sqrt(mu / r);
        }
        
        function getMassFlowRate(altitude) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            const isp = stage.isp * pressureRatio + stage.ispVac * (1 - pressureRatio);
            // Mass flow scales with throttle
            const baseThrust = stage.thrust * pressureRatio + stage.thrustVac * (1 - pressureRatio);
            return (baseThrust * state.throttle) / (isp * 9.81);
        }
        
        function getAirspeed() {
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Earth rotates counterclockwise (eastward), so velocity is perpendicular to position vector
            const atmVx = EARTH_ROTATION * state.y;  // perpendicular to position vector (eastward)
            const atmVy = -EARTH_ROTATION * state.x;
            
            // Airspeed (velocity relative to atmosphere)
            const airVx = state.vx - atmVx;
            const airVy = state.vy - atmVy;
            const airspeed = Math.sqrt(airVx * airVx + airVy * airVy);
            
            return { airspeed, airVx, airVy };
        }
        
        function getDrag(altitude, airspeed) {
            if (state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            const density = getAtmosphericDensity(altitude);
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const area = Math.PI * (stage.diameter / 2) ** 2;
            return 0.5 * density * airspeed * airspeed * stage.dragCoeff * area;
        }
        
        function calculateOrbitalElements() {
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / r);
            const a = -mu / (2 * energy);
            const h = state.x * state.vy - state.y * state.vx;
            const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
            
            if (a > 0 && e < 1) {
                state.apoapsis = a * (1 + e) - EARTH_RADIUS;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
                return { a, sma: a, e, apoapsis: state.apoapsis, periapsis: state.periapsis };
            } else {
                state.apoapsis = Infinity;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
                return { a, sma: a, e: Infinity, apoapsis: state.apoapsis, periapsis: state.periapsis };
            }
        }
        
        function checkMissionStatus() {
            if (gameState.missionComplete || gameState.missionFailed) return;
            
            const altitude = getAltitude();
            const orbital = calculateOrbitalElements();
            
            // Check if in orbit (above 150km and engine off)
            if (altitude > 150000 && !state.engineOn && state.currentStage >= ROCKET_CONFIG.stages.length) {
                // Mission complete - check if orbit matches target
                const avgAltitude = (orbital.apoapsis + orbital.periapsis) / 2;
                const altitudeDiff = Math.abs(avgAltitude - gameState.targetAltitude);
                const eccentricity = orbital.e;
                
                if (eccentricity < gameState.maxEccentricity && altitudeDiff < gameState.targetTolerance) {
                    // Success!
                    gameState.missionComplete = true;
                    calculateFinalScore();
                    document.getElementById('victory-overlay').style.display = 'flex';
                    document.getElementById('victory-score').textContent = `Final Score: ${gameState.score.total.toFixed(0)}`;
                    document.getElementById('mission-status').textContent = 'SUCCESS';
                    document.getElementById('mission-status').className = 'value success';
                } else if (eccentricity >= gameState.maxEccentricity || altitudeDiff >= gameState.targetTolerance * 2) {
                    // Failed - orbit doesn't match
                    gameState.missionFailed = true;
                    let reason = '';
                    if (eccentricity >= gameState.maxEccentricity) {
                        reason = `Orbit too elliptical (e=${eccentricity.toFixed(3)}, max=${gameState.maxEccentricity})`;
                    } else {
                        reason = `Altitude mismatch (${(avgAltitude/1000).toFixed(0)}km, target: ${(gameState.targetAltitude/1000).toFixed(0)}km Â±${(gameState.targetTolerance/1000).toFixed(0)}km)`;
                    }
                    calculateFinalScore();
                    document.getElementById('failure-overlay').style.display = 'flex';
                    document.getElementById('failure-reason').textContent = reason;
                    document.getElementById('failure-score').textContent = `Final Score: ${gameState.score.total.toFixed(0)}`;
                    document.getElementById('mission-status').textContent = 'FAILED';
                    document.getElementById('mission-status').className = 'value fail';
                }
            }
            
            // Check for failure conditions
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            if (r < EARTH_RADIUS && state.time > 1) {
                gameState.missionFailed = true;
                calculateFinalScore();
                document.getElementById('failure-overlay').style.display = 'flex';
                document.getElementById('failure-reason').textContent = 'Ground impact';
                document.getElementById('failure-score').textContent = `Final Score: ${gameState.score.total.toFixed(0)}`;
                state.running = false;
            }
        }
        
        function calculateFinalScore() {
            const altitude = getAltitude();
            const orbital = calculateOrbitalElements();
            const avgAltitude = (orbital.apoapsis + orbital.periapsis) / 2;
            const altitudeDiff = Math.abs(avgAltitude - gameState.targetAltitude);
            
            // Altitude score (0-1000 points, perfect match = 1000)
            if (altitudeDiff < gameState.targetTolerance) {
                gameState.score.altitude = 1000 * (1 - altitudeDiff / gameState.targetTolerance);
            } else {
                gameState.score.altitude = 0;
            }
            
            // Orbit quality score (0-500 points, circular = 500)
            if (orbital.e < gameState.maxEccentricity) {
                gameState.score.orbit = 500 * (1 - orbital.e / gameState.maxEccentricity);
            } else {
                gameState.score.orbit = 0;
            }
            
            // Fuel bonus (0-500 points, more fuel remaining = more points)
            const totalPropellant = ROCKET_CONFIG.stages[0].propellantMass + ROCKET_CONFIG.stages[1].propellantMass;
            const remainingPropellant = state.propellantRemaining.reduce((a, b) => a + b, 0);
            gameState.score.fuel = 500 * (remainingPropellant / totalPropellant);
            
            gameState.score.total = gameState.score.altitude + gameState.score.orbit + gameState.score.fuel;
            
            // Update display
            document.getElementById('alt-score').textContent = gameState.score.altitude.toFixed(0);
            document.getElementById('orbit-score').textContent = gameState.score.orbit.toFixed(0);
            document.getElementById('fuel-score').textContent = gameState.score.fuel.toFixed(0);
            document.getElementById('total-score').textContent = gameState.score.total.toFixed(0);
        }
        
        function update(dt) {
            if (!state.running) return;
            
            dt *= state.timeWarp;
            const maxDt = 1.0;
            if (dt > maxDt) dt = maxDt;
            
            // Handle manual pitch adjustment (scale with time warp)
            if (state.running) {
                updateManualPitch(dt);
            }
            
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            if (r < EARTH_RADIUS && state.time > 1) {
                state.running = false;
                return;
            }
            
            const mass = getTotalMass();
            
            // Gravity
            const gravity = getGravity(r);
            const gx = -gravity * state.x / r;
            const gy = -gravity * state.y / r;
            
            // Local reference frame
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            
            // Thrust direction based on pitch
            const pitchRad = getPitch(state.time) * Math.PI / 180;
            const thrustDir = {
                x: Math.sin(pitchRad) * localUp.x + Math.cos(pitchRad) * localEast.x,
                y: Math.sin(pitchRad) * localUp.y + Math.cos(pitchRad) * localEast.y
            };
            
            // Thrust
            const thrust = getCurrentThrust(altitude);
            const thrustAccel = thrust / mass;
            const tax = thrustAccel * thrustDir.x;
            const tay = thrustAccel * thrustDir.y;
            
            // Drag opposing airspeed (velocity relative to atmosphere)
            const { airspeed, airVx, airVy } = getAirspeed();
            const drag = getDrag(altitude, airspeed);
            const dragAccel = airspeed > 0 ? drag / mass : 0;
            const dax = airspeed > 0 ? -dragAccel * airVx / airspeed : 0;
            const day = airspeed > 0 ? -dragAccel * airVy / airspeed : 0;
            
            // Integration
            const inOrbit = altitude > 150000 && !state.engineOn;
            const maxStepSize = inOrbit ? 0.01 : 0.05;
            const steps = Math.max(1, Math.min(Math.ceil(dt / maxStepSize), 1000));
            const stepDt = dt / steps;
            
            for (let step = 0; step < steps; step++) {
                const rStep = Math.sqrt(state.x * state.x + state.y * state.y);
                const altitudeStep = rStep - EARTH_RADIUS;
                const velocityStep = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                
                const gravityStep = getGravity(rStep);
                const gxStep = -gravityStep * state.x / rStep;
                const gyStep = -gravityStep * state.y / rStep;
                
                const thrustStep = getCurrentThrust(altitudeStep);
                const thrustAccelStep = thrustStep / mass;
                const taxStep = thrustAccelStep * thrustDir.x;
                const tayStep = thrustAccelStep * thrustDir.y;
                
                // Drag at current position (using airspeed)
                // Earth rotates counterclockwise (eastward)
                const atmVxStep = EARTH_ROTATION * state.y;  // eastward
                const atmVyStep = -EARTH_ROTATION * state.x;
                const airVxStep = state.vx - atmVxStep;
                const airVyStep = state.vy - atmVyStep;
                const airspeedStep = Math.sqrt(airVxStep * airVxStep + airVyStep * airVyStep);
                const dragStep = getDrag(altitudeStep, airspeedStep);
                const dragAccelStep = airspeedStep > 0 ? dragStep / mass : 0;
                const daxStep = airspeedStep > 0 ? -dragAccelStep * airVxStep / airspeedStep : 0;
                const dayStep = airspeedStep > 0 ? -dragAccelStep * airVyStep / airspeedStep : 0;
                
                const axStep = gxStep + taxStep + daxStep;
                const ayStep = gyStep + tayStep + dayStep;
                
                state.vx += axStep * stepDt;
                state.vy += ayStep * stepDt;
                state.x += state.vx * stepDt;
                state.y += state.vy * stepDt;
            }
            
            // Propellant consumption
            if (state.engineOn && state.currentStage < ROCKET_CONFIG.stages.length) {
                state.propellantRemaining[state.currentStage] -= getMassFlowRate(altitude) * dt;
                
                if (state.propellantRemaining[state.currentStage] <= 0) {
                    state.propellantRemaining[state.currentStage] = 0;
                    if (state.currentStage === 0) {
                        state.currentStage = 1;
                    } else {
                        state.engineOn = false;
                    }
                }
            }
            
            if (!state.fairingJettisoned && altitude > ROCKET_CONFIG.fairingJettisonAlt) {
                state.fairingJettisoned = true;
            }
            
            // Dynamic pressure using airspeed (velocity relative to atmosphere)
            const { airspeed: airspeedForQ } = getAirspeed();
            const dynPress = 0.5 * getAtmosphericDensity(altitude) * airspeedForQ * airspeedForQ;
            if (dynPress > state.maxQ) state.maxQ = dynPress;
            
            calculateOrbitalElements();
            
            if (state.time % 0.1 < dt * state.timeWarp) {
                state.trail.push({ x: state.x, y: state.y });
                if (state.trail.length > 10000) state.trail.shift();
            }
            
            // Check mission status periodically
            gameState.checkInterval -= dt;
            if (gameState.checkInterval <= 0) {
                checkMissionStatus();
                gameState.checkInterval = 0.5;
            }
            
            state.time += dt;
            updateTelemetry();
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }
        
        function calculateRecommendedPitch(altitude, velocity, vVert, vHoriz, orbital) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) {
                return null;
            }
            
            const targetAlt = gameState.targetAltitude;
            const currentAlt = altitude;
            
            // Estimate remaining burn time and fuel
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const remainingFuel = state.propellantRemaining[state.currentStage];
            const fuelPercent = remainingFuel / stage.propellantMass;
            
            // Simple guidance: balance between reaching altitude and gaining horizontal velocity
            // If too low, pitch up more. If too high but need more horizontal velocity, pitch down.
            
            if (currentAlt < 10000) {
                // Early ascent: pitch down gradually from 90Â° to ~80Â°
                return Math.max(80, 90 - (currentAlt / 10000) * 10);
            }
            
            if (currentAlt < 50000) {
                // Mid ascent: pitch down more aggressively
                const progress = (currentAlt - 10000) / 40000;
                return 80 - progress * 30; // 80Â° to 50Â°
            }
            
            // Higher altitude: adjust based on predicted orbit
            let recommendedPitch = 45;
            
            if (orbital.e !== Infinity) {
                const avgAlt = (orbital.apoapsis + orbital.periapsis) / 2;
                const altDiff = avgAlt - targetAlt;
                const ecc = orbital.e;
                
                // If predicted altitude is too low, pitch up more
                if (altDiff < -gameState.targetTolerance) {
                    recommendedPitch = Math.min(70, 45 + Math.abs(altDiff) / 10000 * 5);
                }
                // If predicted altitude is too high, pitch down
                else if (altDiff > gameState.targetTolerance) {
                    recommendedPitch = Math.max(15, 45 - altDiff / 10000 * 5);
                }
                // If eccentricity is too high, need more horizontal velocity (pitch down)
                else if (ecc > gameState.maxEccentricity) {
                    recommendedPitch = Math.max(20, recommendedPitch - (ecc - gameState.maxEccentricity) * 100);
                }
                // If altitude is good but need more circularization
                else {
                    recommendedPitch = Math.max(10, 45 - (ecc / gameState.maxEccentricity) * 20);
                }
            } else {
                // No orbit yet, use altitude-based guidance
                if (currentAlt < targetAlt * 0.7) {
                    recommendedPitch = 60 - (currentAlt / targetAlt) * 30;
                } else {
                    recommendedPitch = 30 - ((currentAlt - targetAlt * 0.7) / (targetAlt * 0.3)) * 20;
                }
            }
            
            // Adjust based on vertical velocity ratio
            if (vVert > 0 && velocity > 0) {
                const vertRatio = vVert / velocity;
                if (vertRatio > 0.6) {
                    recommendedPitch = Math.min(recommendedPitch + 10, 80); // Too vertical, pitch down more
                } else if (vertRatio < 0.3 && currentAlt > targetAlt * 0.8) {
                    recommendedPitch = Math.max(recommendedPitch - 10, 10); // Need more horizontal, pitch down
                }
            }
            
            return Math.max(0, Math.min(90, recommendedPitch));
        }
        
        function predictFinalOrbit() {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) {
                // Use current orbit if engine is off
                return calculateOrbitalElements();
            }
            
            // Simple prediction: estimate based on current trajectory
            // This is approximate - would need full simulation for accuracy
            const orbital = calculateOrbitalElements();
            if (orbital.e !== Infinity) {
                return orbital;
            }
            return null;
        }
        
        function updateTelemetry() {
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const orbital = calculateOrbitalElements();
            
            // Calculate local reference frame for velocity components
            const localUp = { x: state.x / r, y: state.y / r };
            const vVert = state.vx * localUp.x + state.vy * localUp.y;
            const vHoriz = Math.sqrt(Math.max(0, velocity * velocity - vVert * vVert));
            const downrange = Math.atan2(state.x, state.y) * EARTH_RADIUS;
            
            // Update telemetry display
            document.getElementById('time').textContent = formatTime(state.time);
            document.getElementById('stage').textContent = state.currentStage + 1;
            document.getElementById('altitude').textContent = (altitude / 1000).toFixed(2) + ' km';
            document.getElementById('downrange').textContent = (downrange / 1000).toFixed(1) + ' km';
            document.getElementById('velocity').textContent = velocity.toFixed(0) + ' m/s';
            document.getElementById('vvel').textContent = vVert.toFixed(0) + ' m/s';
            document.getElementById('hvel').textContent = vHoriz.toFixed(0) + ' m/s';
            
            const thrust = getCurrentThrust(altitude);
            const mass = getTotalMass();
            document.getElementById('accel').textContent = (thrust / mass / 9.81).toFixed(2) + ' G';
            document.getElementById('maxq').textContent = (state.maxQ / 1000).toFixed(2) + ' kPa';
            const { airspeed: airspeedForDisplay } = getAirspeed();
            document.getElementById('dynpress').textContent = (0.5 * getAtmosphericDensity(altitude) * airspeedForDisplay * airspeedForDisplay / 1000).toFixed(2) + ' kPa';
            document.getElementById('mass').textContent = mass.toFixed(0) + ' kg';
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            if (stage) {
                document.getElementById('propellant').textContent = (state.propellantRemaining[state.currentStage] / stage.propellantMass * 100).toFixed(1) + '%';
            }
            document.getElementById('thrust').textContent = (thrust / 1000).toFixed(0) + ' kN';
            
            // Update throttle display
            document.getElementById('throttle-display').textContent = (state.throttle * 100).toFixed(0) + '%';
            
            // Calculate and display target orbital velocity (always shown)
            const targetOrbitalV = getOrbitalVelocity(gameState.targetAltitude);
            
            // Calculate velocity deficit (reuse vHoriz calculated above)
            const velocityDeficit = targetOrbitalV - vHoriz;
            
            const pitch = getPitch(state.time);
            document.getElementById('pitch').textContent = pitch.toFixed(1) + 'Â°';
            document.getElementById('apoapsis').textContent = orbital.apoapsis === Infinity ? 'ESCAPE' : (orbital.apoapsis / 1000).toFixed(1) + ' km';
            document.getElementById('periapsis').textContent = (orbital.periapsis / 1000).toFixed(1) + ' km';
            
            // Update game panel
            document.getElementById('current-alt').textContent = (altitude / 1000).toFixed(1) + ' km';
            if (orbital.e !== Infinity) {
                document.getElementById('current-ecc').textContent = orbital.e.toFixed(3);
            } else {
                document.getElementById('current-ecc').textContent = '-';
            }
            
            // Match status
            if (!state.engineOn && altitude > 150000 && state.currentStage >= ROCKET_CONFIG.stages.length) {
                const avgAltitude = (orbital.apoapsis + orbital.periapsis) / 2;
                const altitudeDiff = Math.abs(avgAltitude - gameState.targetAltitude);
                const eccMatch = orbital.e < gameState.maxEccentricity;
                const altMatch = altitudeDiff < gameState.targetTolerance;
                
                if (altMatch && eccMatch) {
                    document.getElementById('match-status').textContent = 'MATCH';
                    document.getElementById('match-status').className = 'value success';
                } else if (altMatch || eccMatch) {
                    document.getElementById('match-status').textContent = 'PARTIAL';
                    document.getElementById('match-status').className = 'value warning';
                } else {
                    document.getElementById('match-status').textContent = 'NO MATCH';
                    document.getElementById('match-status').className = 'value fail';
                }
                
                // Update score in real-time
                calculateFinalScore();
            } else {
                document.getElementById('match-status').textContent = '-';
                document.getElementById('match-status').className = 'value';
            }
            
            // Update pitch display
            document.getElementById('current-pitch-display').textContent = pitch.toFixed(1) + 'Â°';
            
            // Update guidance panel
            
            if (state.engineOn && state.running) {
                // Pitch direction hint - just show static message
                document.getElementById('pitch-direction-hint').textContent = 'Adjust pitch during flight';
                document.getElementById('pitch-direction-hint').className = 'direction';
                
                // Trajectory status based on current orbit
                let trajectoryStatus = 'ASCENDING';
                let trajectoryClass = 'warning';
                let hint = '';
                
                if (orbital.e !== Infinity && altitude > 150000) {
                    const avgAlt = (orbital.apoapsis + orbital.periapsis) / 2;
                    const altDiff = Math.abs(avgAlt - gameState.targetAltitude);
                    const ecc = orbital.e;
                    
                    if (altDiff < gameState.targetTolerance && ecc < gameState.maxEccentricity) {
                        trajectoryStatus = 'ON TARGET';
                        trajectoryClass = 'good';
                        hint = 'Keep current trajectory!';
                    } else if (altDiff < gameState.targetTolerance * 2 || ecc < gameState.maxEccentricity * 2) {
                        trajectoryStatus = 'CLOSE';
                        trajectoryClass = 'warning';
                        if (altDiff > gameState.targetTolerance) {
                            hint = 'Altitude slightly off: ' + (avgAlt > gameState.targetAltitude ? 'too high' : 'too low');
                        } else {
                            hint = 'Orbit slightly elliptical, pitch down to circularize';
                        }
                    } else {
                        trajectoryStatus = 'NEEDS ADJUST';
                        trajectoryClass = 'bad';
                        if (avgAlt < gameState.targetAltitude - gameState.targetTolerance) {
                            hint = 'Orbit too LOW - pitch UP more';
                        } else if (avgAlt > gameState.targetAltitude + gameState.targetTolerance) {
                            hint = 'Orbit too HIGH - pitch DOWN more';
                        } else if (ecc > gameState.maxEccentricity) {
                            hint = 'Orbit too elliptical - pitch DOWN to gain horizontal velocity';
                        }
                    }
                } else {
                    hint = 'Continue ascending, pitch down as you gain altitude';
                }
                
                // Display horizontal velocity
                document.getElementById('horiz-velocity').textContent = vHoriz.toFixed(0) + ' m/s';
                
                // Display velocity deficit with color coding
                const deficitElement = document.getElementById('velocity-deficit');
                deficitElement.textContent = (velocityDeficit > 0 ? '+' : '') + velocityDeficit.toFixed(0) + ' m/s';
                if (velocityDeficit < 100) {
                    deficitElement.className = 'value good';
                } else if (velocityDeficit < 500) {
                    deficitElement.className = 'value warning';
                } else {
                    deficitElement.className = 'value bad';
                }
                
                // Display eccentricity
                const eccElement = document.getElementById('guidance-ecc');
                if (orbital.e !== Infinity) {
                    eccElement.textContent = orbital.e.toFixed(3);
                    if (orbital.e < gameState.maxEccentricity) {
                        eccElement.className = 'value good';
                    } else if (orbital.e < gameState.maxEccentricity * 2) {
                        eccElement.className = 'value warning';
                    } else {
                        eccElement.className = 'value bad';
                    }
                } else {
                    eccElement.textContent = '-';
                    eccElement.className = 'value';
                }
                
                document.getElementById('trajectory-status').textContent = trajectoryStatus;
                document.getElementById('trajectory-status').className = 'value ' + trajectoryClass;
                const throttleHint = 'â†‘â†“ Arrow keys to throttle';
                document.getElementById('guidance-hint').textContent = (hint || 'Adjust pitch to reach target orbit') + '<br>' + throttleHint;
            } else {
                document.getElementById('pitch-direction-hint').textContent = 'Ready to launch';
                document.getElementById('trajectory-status').textContent = '-';
                document.getElementById('horiz-velocity').textContent = '-';
                document.getElementById('velocity-deficit').textContent = '-';
                document.getElementById('velocity-deficit').className = 'value';
                document.getElementById('guidance-ecc').textContent = '-';
                document.getElementById('guidance-ecc').className = 'value';
                document.getElementById('guidance-hint').innerHTML = 'Launch to begin guidance<br>â†‘â†“ Arrow keys to throttle';
            }
            
            // Always update target orbital velocity (shown in guidance panel)
            document.getElementById('target-orbital-v').textContent = targetOrbitalV.toFixed(0) + ' m/s';
            
            // Update mission status
            if (state.running && !gameState.missionComplete && !gameState.missionFailed) {
                if (state.engineOn) {
                    document.getElementById('mission-status').textContent = 'ASCENDING';
                    document.getElementById('mission-status').className = 'value';
                } else if (altitude > 150000) {
                    document.getElementById('mission-status').textContent = 'IN ORBIT';
                    document.getElementById('mission-status').className = 'value';
                }
            }
        }
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const altitude = getAltitude();
            
            // Zoom
            const minMPP = 2;
            const maxMPP = state.cameraMode === 'earth' ? Infinity : (EARTH_RADIUS * 20 / Math.min(canvas.width, canvas.height));
            
            let autoMetersPerPixel;
            if (state.cameraMode === 'earth') {
                const defaultEarthZoom = EARTH_RADIUS * 2.5 / Math.min(canvas.width, canvas.height);
                autoMetersPerPixel = defaultEarthZoom;
            } else if (altitude < 500) {
                autoMetersPerPixel = minMPP;
            } else {
                const zoomProgress = Math.min(1, Math.log10(altitude / 500) / 6);
                autoMetersPerPixel = minMPP * Math.pow(maxMPP / minMPP, zoomProgress);
            }
            
            const metersPerPixel = (state.cameraMode === 'earth' || !state.autoZoom) 
                ? autoMetersPerPixel / state.manualZoom 
                : autoMetersPerPixel / state.manualZoom;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 200; i++) {
                const sx = (Math.sin(i * 567.89 + 1000) * 0.5 + 0.5) * canvas.width;
                const sy = (Math.cos(i * 123.45 + 500) * 0.5 + 0.5) * canvas.height;
                ctx.fillRect(sx, sy, Math.random() > 0.85 ? 2 : 1, 1);
            }
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(1 / metersPerPixel, -1 / metersPerPixel);
            
            if (state.cameraMode === 'earth') {
                ctx.translate(0, 0);
            } else {
                ctx.translate(-state.x, -state.y);
            }
            
            // Earth
            ctx.beginPath();
            ctx.arc(0, 0, EARTH_RADIUS, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(-EARTH_RADIUS * 0.3, EARTH_RADIUS * 0.3, 0, 0, 0, EARTH_RADIUS);
            grad.addColorStop(0, '#3a7d32');
            grad.addColorStop(0.6, '#1a5a1a');
            grad.addColorStop(1, '#0a3a0a');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#2a8a2a';
            ctx.lineWidth = metersPerPixel * 2;
            ctx.stroke();
            
            // Target orbit visualization
            if (metersPerPixel > 200) {
                ctx.beginPath();
                ctx.arc(0, 0, EARTH_RADIUS + gameState.targetAltitude, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 5000;
                ctx.setLineDash([20000, 10000]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Trail
            if (state.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(state.trail[0].x, state.trail[0].y);
                for (let i = 1; i < state.trail.length; i++) {
                    ctx.lineTo(state.trail[i].x, state.trail[i].y);
                }
                ctx.strokeStyle = 'rgba(255, 120, 0, 0.8)';
                ctx.lineWidth = Math.max(metersPerPixel * 2, 2);
                ctx.stroke();
            }
            
            // Rocket
            const rocketLen = 70;
            const rocketWid = 3.7;
            
            ctx.save();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            ctx.translate(state.x + localUp.x * rocketLen * 0.5, state.y + localUp.y * rocketLen * 0.5);
            
            const pitchRad = getPitch(state.time) * Math.PI / 180;
            const thrustDir = {
                x: Math.sin(pitchRad) * localUp.x + Math.cos(pitchRad) * localEast.x,
                y: Math.sin(pitchRad) * localUp.y + Math.cos(pitchRad) * localEast.y
            };
            
            const rocketAngle = Math.atan2(thrustDir.y, thrustDir.x) - Math.PI / 2;
            ctx.rotate(rocketAngle);
            
            const minPixelSize = 12;
            const scale = Math.max(1, minPixelSize * metersPerPixel / rocketLen);
            const drawLen = rocketLen * scale;
            const drawWid = rocketWid * scale;
            
            // Body
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(-drawWid/2, -drawLen * 0.4, drawWid, drawLen * 0.8);
            
            // Nose
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, drawLen * 0.4);
            ctx.lineTo(0, drawLen * 0.55);
            ctx.lineTo(drawWid/2, drawLen * 0.4);
            ctx.fillStyle = '#d33';
            ctx.fill();
            
            // Fins
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, -drawLen * 0.35);
            ctx.lineTo(-drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(-drawWid/2, -drawLen * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(drawWid/2, -drawLen * 0.35);
            ctx.lineTo(drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(drawWid/2, -drawLen * 0.2);
            ctx.fill();
            
            // Flame
            if (state.engineOn && state.propellantRemaining[state.currentStage] > 0) {
                const flameLen = drawLen * (0.5 + Math.random() * 0.25);
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.2, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, 0, -drawLen * 0.4 - flameLen);
                ctx.quadraticCurveTo(drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, drawWid * 0.2, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${80 + Math.random() * 60}, 0)`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.1, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, 0, -drawLen * 0.4 - flameLen * 0.6);
                ctx.quadraticCurveTo(drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, drawWid * 0.1, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${200 + Math.random() * 55}, ${100 + Math.random() * 80})`;
                ctx.fill();
            }
            
            // Orbit prediction - show developing orbit
            const rOrbit = Math.sqrt(state.x * state.x + state.y * state.y);
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / rOrbit);
            if (altitude > 10000 && energy < 0) {
                const a = -mu / (2 * energy);
                const h = state.x * state.vy - state.y * state.vx;
                const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
                if (e < 1 && a > 0 && a < EARTH_RADIUS * 50 && e > 0.001) {
                    // Calculate orbit orientation using eccentricity vector
                    const v2 = v * v;
                    const rVec = { x: state.x, y: state.y };
                    const vVec = { x: state.vx, y: state.vy };
                    
                    const rDotV = rVec.x * vVec.x + rVec.y * vVec.y;
                    const eVec = {
                        x: ((v2 - mu / rOrbit) * rVec.x - rDotV * vVec.x) / mu,
                        y: ((v2 - mu / rOrbit) * rVec.y - rDotV * vVec.y) / mu
                    };
                    
                    const periapsisAngle = Math.atan2(eVec.y, eVec.x);
                    const rDotE = rVec.x * eVec.x + rVec.y * eVec.y;
                    const cosNu = Math.max(-1, Math.min(1, rDotE / (rOrbit * e)));
                    const rDotVNorm = rDotV / Math.sqrt(mu * a);
                    const sinNu = Math.max(-1, Math.min(1, rDotVNorm / e));
                    const nu = Math.atan2(sinNu, cosNu);
                    const theta0 = periapsisAngle;
                    
                    ctx.save();
                    ctx.beginPath();
                    let firstPoint = true;
                    let lastValidPoint = null;
                    for (let ang = 0; ang <= Math.PI * 2 + 0.05; ang += 0.01) {
                        const rOrb = a * (1 - e * e) / (1 + e * Math.cos(ang));
                        if (rOrb > EARTH_RADIUS && rOrb < EARTH_RADIUS * 50 && isFinite(rOrb)) {
                            const xO = rOrb * Math.cos(ang + theta0);
                            const yO = rOrb * Math.sin(ang + theta0);
                            if (isFinite(xO) && isFinite(yO)) {
                                if (firstPoint) {
                                    ctx.moveTo(xO, yO);
                                    firstPoint = false;
                                    lastValidPoint = { x: xO, y: yO };
                                } else {
                                    if (lastValidPoint) {
                                        const dx = xO - lastValidPoint.x;
                                        const dy = yO - lastValidPoint.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < EARTH_RADIUS * 10) {
                                            ctx.lineTo(xO, yO);
                                            lastValidPoint = { x: xO, y: yO };
                                        }
                                    } else {
                                        ctx.lineTo(xO, yO);
                                        lastValidPoint = { x: xO, y: yO };
                                    }
                                }
                            }
                        }
                    }
                    // Color orbit based on how well it matches target
                    const orbital = calculateOrbitalElements();
                    const avgAlt = (orbital.apoapsis + orbital.periapsis) / 2;
                    const altDiff = Math.abs(avgAlt - gameState.targetAltitude);
                    const altMatch = altDiff < gameState.targetTolerance;
                    const eccMatch = orbital.e < gameState.maxEccentricity;
                    
                    if (altMatch && eccMatch) {
                        ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Green for good match
                    } else if (altMatch || eccMatch) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow for partial
                    } else {
                        ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)'; // Cyan for developing
                    }
                    ctx.lineWidth = Math.max(metersPerPixel * 3, 2);
                    ctx.setLineDash([metersPerPixel * 20, metersPerPixel * 10]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                    
                    // Mark periapsis and apoapsis
                    if (metersPerPixel < 10000) {
                        const periX = (EARTH_RADIUS + orbital.periapsis) * Math.cos(periapsisAngle);
                        const periY = (EARTH_RADIUS + orbital.periapsis) * Math.sin(periapsisAngle);
                        const apoX = -(EARTH_RADIUS + orbital.apoapsis) * Math.cos(periapsisAngle);
                        const apoY = -(EARTH_RADIUS + orbital.apoapsis) * Math.sin(periapsisAngle);
                        
                        ctx.save();
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(periX, periY, metersPerPixel * 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#0ff';
                        ctx.beginPath();
                        ctx.arc(apoX, apoY, metersPerPixel * 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
            
            ctx.restore();
            ctx.restore();
        }
        
        let lastTime = 0;
        function loop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            update(dt);
            render();
            renderOrbitalView();
            requestAnimationFrame(loop);
        }
        
        function renderOrbitalView() {
            orbitalCtx.fillStyle = '#000';
            orbitalCtx.fillRect(0, 0, orbitalCanvas.width, orbitalCanvas.height);
            
            const altitude = getAltitude();
            const orbital = calculateOrbitalElements();
            
            const centerX = orbitalCanvas.width / 2;
            const canvasHeight = orbitalCanvas.height;
            const canvasWidth = orbitalCanvas.width;
            
            // Simple altitude scale - zoomed in around target orbit
            // Show Â±150km range from target
            const viewRange = 600000; // Â±300 km
            const targetAlt = gameState.targetAltitude;
            const minAlt = Math.max(0, targetAlt - viewRange / 2);
            const maxAlt = targetAlt + viewRange / 2;
            
            // Scale: map altitude to Y position (top = high altitude, bottom = low altitude)
            const scale = canvasHeight / viewRange;
            const targetY = canvasHeight - ((targetAlt - minAlt) * scale);
            
            // Draw target orbit line - OBVIOUS and clear
            orbitalCtx.strokeStyle = '#0ff'; // Bright cyan
            orbitalCtx.lineWidth = 3;
            orbitalCtx.setLineDash([10, 5]);
            orbitalCtx.beginPath();
            orbitalCtx.moveTo(20, targetY);
            orbitalCtx.lineTo(canvasWidth - 20, targetY);
            orbitalCtx.stroke();
            orbitalCtx.setLineDash([]);
            
            // Draw target tolerance band
            const targetTolTop = canvasHeight - ((targetAlt + gameState.targetTolerance - minAlt) * scale);
            const targetTolBottom = canvasHeight - ((targetAlt - gameState.targetTolerance - minAlt) * scale);
            orbitalCtx.fillStyle = 'rgba(0, 255, 255, 0.15)';
            orbitalCtx.fillRect(20, targetTolTop, canvasWidth - 40, targetTolBottom - targetTolTop);
            
            // Label target orbit
            orbitalCtx.fillStyle = '#0ff';
            orbitalCtx.font = 'bold 11px Courier New';
            orbitalCtx.textAlign = 'left';
            orbitalCtx.fillText('TARGET ORBIT', 25, targetY - 5);
            
            // Draw altitude scale markers
            orbitalCtx.strokeStyle = '#444';
            orbitalCtx.lineWidth = 1;
            orbitalCtx.font = '9px Courier New';
            orbitalCtx.fillStyle = '#888';
            orbitalCtx.textAlign = 'right';
            for (let alt = Math.ceil(minAlt / 50000) * 50000; alt <= maxAlt; alt += 50000) {
                const y = canvasHeight - ((alt - minAlt) * scale);
                orbitalCtx.beginPath();
                orbitalCtx.moveTo(15, y);
                orbitalCtx.lineTo(20, y);
                orbitalCtx.stroke();
                orbitalCtx.fillText((alt / 1000).toFixed(0) + 'km', 18, y + 3);
            }
            
            // Draw rocket as a dot
            if (altitude >= 0) {
                const rocketY = canvasHeight - ((altitude - minAlt) * scale);
                // Clamp to canvas bounds
                if (rocketY >= 0 && rocketY <= canvasHeight) {
                    // Draw rocket dot
                    orbitalCtx.fillStyle = '#f00';
                    orbitalCtx.beginPath();
                    orbitalCtx.arc(centerX, rocketY, 6, 0, Math.PI * 2);
                    orbitalCtx.fill();
                    // Add white border for visibility
                    orbitalCtx.strokeStyle = '#fff';
                    orbitalCtx.lineWidth = 2;
                    orbitalCtx.stroke();
                    
                    // Show current altitude
                    orbitalCtx.fillStyle = '#f00';
                    orbitalCtx.font = 'bold 10px Courier New';
                    orbitalCtx.textAlign = 'center';
                    orbitalCtx.fillText((altitude / 1000).toFixed(1) + ' km', centerX, rocketY - 10);
                }
            }
            
            // If in orbit, show predicted orbit range
            if (orbital.e !== Infinity && orbital.e >= 0 && altitude > 15000) {
                const avgAlt = (orbital.apoapsis + orbital.periapsis) / 2;
                const avgY = canvasHeight - ((avgAlt - minAlt) * scale);
                const apoY = canvasHeight - ((orbital.apoapsis - minAlt) * scale);
                const periY = canvasHeight - ((orbital.periapsis - minAlt) * scale);
                
                // Color based on match
                const altDiff = Math.abs(avgAlt - targetAlt);
                const altMatch = altDiff < gameState.targetTolerance;
                const eccMatch = orbital.e < gameState.maxEccentricity;
                
                let orbitColor = '#f80'; // Orange
                if (altMatch && eccMatch) {
                    orbitColor = '#0f0'; // Green
                } else if (altMatch || eccMatch) {
                    orbitColor = '#ff0'; // Yellow
                }
                
                // Draw orbit range as a bar on the right side
                const rangeBarX = canvasWidth - 30;
                orbitalCtx.fillStyle = orbitColor;
                orbitalCtx.fillRect(rangeBarX, Math.min(apoY, periY), 15, Math.abs(apoY - periY));
                orbitalCtx.strokeStyle = orbitColor;
                orbitalCtx.lineWidth = 2;
                // Mark average
                orbitalCtx.beginPath();
                orbitalCtx.moveTo(rangeBarX - 5, avgY);
                orbitalCtx.lineTo(rangeBarX + 20, avgY);
                orbitalCtx.stroke();
            }
            
            // Update orbital info
            if (orbital.e !== Infinity && orbital.e >= 0) {
                document.getElementById('orb-apo').textContent = (orbital.apoapsis / 1000).toFixed(1) + ' km';
                document.getElementById('orb-peri').textContent = (orbital.periapsis / 1000).toFixed(1) + ' km';
                document.getElementById('orb-ecc').textContent = orbital.e.toFixed(4);
                const sma = ((EARTH_RADIUS + orbital.apoapsis) + (EARTH_RADIUS + orbital.periapsis)) / 2;
                document.getElementById('orb-sma').textContent = (sma / 1000).toFixed(1) + ' km';
            } else {
                document.getElementById('orb-apo').textContent = '-';
                document.getElementById('orb-peri').textContent = '-';
                document.getElementById('orb-ecc').textContent = '-';
                document.getElementById('orb-sma').textContent = '-';
            }
        }
        
        // Manual pitch control buttons
        let pitchUpHeld = false;
        let pitchDownHeld = false;
        
        function updateManualPitch(dt) {
            if (manualPitch === null) {
                manualPitch = getPitch(state.time);
            }
            
            // Realistic pitch change rate (degrees per second, not multiplied)
            if (pitchUpHeld) {
                manualPitch = Math.min(90, manualPitch + pitchAdjustSpeed * dt);
            }
            if (pitchDownHeld) {
                manualPitch = Math.max(0, manualPitch - pitchAdjustSpeed * dt);
            }
        }
        
        document.getElementById('pitch-up-btn').addEventListener('mousedown', () => {
            pitchUpHeld = true;
            if (manualPitch === null) manualPitch = getPitch(state.time);
        });
        document.getElementById('pitch-up-btn').addEventListener('mouseup', () => {
            pitchUpHeld = false;
        });
        document.getElementById('pitch-up-btn').addEventListener('mouseleave', () => {
            pitchUpHeld = false;
        });
        
        document.getElementById('pitch-down-btn').addEventListener('mousedown', () => {
            pitchDownHeld = true;
            if (manualPitch === null) manualPitch = getPitch(state.time);
        });
        document.getElementById('pitch-down-btn').addEventListener('mouseup', () => {
            pitchDownHeld = false;
        });
        document.getElementById('pitch-down-btn').addEventListener('mouseleave', () => {
            pitchDownHeld = false;
        });
        
        // Keyboard controls
        let throttleAdjustRate = 0.05; // Change throttle by 5% per keypress
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'W') {
                pitchUpHeld = true;
                if (manualPitch === null) manualPitch = getPitch(state.time);
            }
            if (e.key === 's' || e.key === 'S') {
                pitchDownHeld = true;
                if (manualPitch === null) manualPitch = getPitch(state.time);
            }
            // Throttle controls (Arrow keys)
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                state.throttle = Math.min(1.0, state.throttle + throttleAdjustRate);
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                state.throttle = Math.max(0.0, state.throttle - throttleAdjustRate);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') pitchUpHeld = false;
            if (e.key === 's' || e.key === 'S') pitchDownHeld = false;
        });
        
        document.getElementById('launch-btn').addEventListener('click', () => {
            if (!state.running && state.time === 0) {
                state.running = true;
                state.engineOn = true;
                document.getElementById('launch-btn').disabled = true;
                document.getElementById('launch-btn').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'inline-block';
            }
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            if (state.running) {
                state.running = false;
                document.getElementById('pause-btn').textContent = 'RESUME';
            } else {
                state.running = true;
                document.getElementById('pause-btn').textContent = 'PAUSE';
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('pause-btn').textContent = 'PAUSE';
            updateTelemetry();
        });
        
        const speeds = [1, 2, 5, 10, 25, 50, 100, 500, 1000];
        let speedIdx = 0;
        document.getElementById('speed-btn').addEventListener('click', () => {
            speedIdx = (speedIdx + 1) % speeds.length;
            state.timeWarp = speeds[speedIdx];
            document.getElementById('speed-btn').textContent = speeds[speedIdx] + 'x';
        });
        
        document.getElementById('new-mission-btn').addEventListener('click', () => {
            generateNewMission();
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            updateTelemetry();
        });
        
        document.getElementById('victory-continue-btn').addEventListener('click', () => {
            generateNewMission();
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            updateTelemetry();
        });
        
        document.getElementById('failure-retry-btn').addEventListener('click', () => {
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            updateTelemetry();
        });
        
        // Initialize
        generateNewMission();
        initState();
        updateTelemetry();
        requestAnimationFrame(loop);
    </script>
</body>
</html>

