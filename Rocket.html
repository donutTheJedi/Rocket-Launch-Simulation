<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Rocket Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
        }
        
        #canvas {
            background: #000;
        }
        
        #telemetry {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-size: 13px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
            min-width: 280px;
        }
        
        #telemetry h3 {
            color: #0ff;
            margin-bottom: 10px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }
        
        .section {
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .label {
            color: #888;
        }
        
        .value {
            color: #0f0;
            float: right;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #events {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0ff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 5px;
            max-width: 250px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #burn-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 5px;
            min-width: 150px;
        }
        
        #burn-controls button {
            width: 100%;
            padding: 8px;
            font-size: 11px;
        }
        
        #burn-controls button.active {
            background: #0ff;
            color: #000;
        }
        
        #events h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }
        
        .event {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #333;
            font-size: 11px;
        }
        
        .event-time {
            color: #888;
        }
        
        #pitch-program {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #f80;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #f80;
            border-radius: 5px;
            width: 200px;
        }
        
        #pitch-program h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #f80;
            padding-bottom: 5px;
        }
        
        .pitch-bar {
            width: 100%;
            height: 20px;
            background: #333;
            margin-top: 10px;
            position: relative;
        }
        
        .pitch-indicator {
            height: 100%;
            background: linear-gradient(90deg, #f80, #ff0);
            transition: width 0.1s;
        }
        
        #tminus-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border: 2px solid #0ff;
            border-radius: 5px;
            text-align: center;
            display: none;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        #tminus-display .tminus-time {
            font-size: 32px;
            color: #0ff;
            margin-bottom: 5px;
        }
        
        #tminus-display .tminus-event {
            font-size: 14px;
            color: #0f0;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="tminus-display">
        <div class="tminus-time" id="tminus-time">T- 00:00</div>
        <div class="tminus-event" id="tminus-event-name">Next Event</div>
    </div>
    
    <div id="telemetry">
        <h3>TELEMETRY</h3>
        <div class="section">
            <div><span class="label">T+</span><span class="value" id="time">00:00:00</span></div>
            <div><span class="label">Stage</span><span class="value" id="stage">1</span></div>
        </div>
        <div class="section">
            <div><span class="label">Altitude</span><span class="value" id="altitude">0 km</span></div>
            <div><span class="label">Downrange</span><span class="value" id="downrange">0 km</span></div>
            <div><span class="label">Velocity</span><span class="value" id="velocity">0 m/s</span></div>
            <div><span class="label">Vertical V</span><span class="value" id="vvel">0 m/s</span></div>
            <div><span class="label">Horizontal V</span><span class="value" id="hvel">0 m/s</span></div>
        </div>
        <div class="section">
            <div><span class="label">Acceleration</span><span class="value" id="accel">0 G</span></div>
            <div><span class="label">Max Q</span><span class="value" id="maxq">0 kPa</span></div>
            <div><span class="label">Dynamic Press</span><span class="value" id="dynpress">0 kPa</span></div>
        </div>
        <div class="section">
            <div><span class="label">Mass</span><span class="value" id="mass">0 kg</span></div>
            <div><span class="label">Propellant</span><span class="value" id="propellant">0%</span></div>
            <div><span class="label">Thrust</span><span class="value" id="thrust">0 kN</span></div>
        </div>
        <div class="section">
            <div><span class="label">Pitch</span><span class="value" id="pitch">90°</span></div>
            <div><span class="label">Apoapsis</span><span class="value" id="apoapsis">0 km</span></div>
            <div><span class="label">Periapsis</span><span class="value" id="periapsis">0 km</span></div>
        </div>
    </div>
    
    <div id="events">
        <h3>MISSION EVENTS</h3>
        <div id="event-list"></div>
    </div>
    
    <div id="pitch-program">
        <h3>PITCH PROGRAM</h3>
        <div><span class="label">Target:</span> <span id="target-pitch">90°</span></div>
        <div><span class="label">Current:</span> <span id="current-pitch">90°</span></div>
        <div class="pitch-bar">
            <div class="pitch-indicator" id="pitch-bar"></div>
        </div>
    </div>
    
    <div id="controls">
        <button id="launch-btn">LAUNCH</button>
        <button id="pause-btn" style="display: none;">PAUSE</button>
        <button id="reset-btn">RESET</button>
        <button id="speed-btn">1x</button>
        <button id="zoom-out-btn">ZOOM OUT</button>
        <button id="zoom-in-btn">ZOOM IN</button>
        <button id="zoom-auto-btn">AUTO ZOOM</button>
        <button id="camera-btn">FOLLOW ROCKET</button>
    </div>
    
    <div id="burn-controls" style="display: none;">
        <h3 style="color: #0ff; margin-bottom: 10px;">ORBITAL BURNS</h3>
        <div id="burn-status" style="color: #0f0; font-size: 11px; margin-bottom: 10px; min-height: 30px;">
            <div>Hold button to burn</div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <button id="refuel-btn" style="background: #2a2; border-color: #2a2; margin-bottom: 5px;">REFUEL (5000 kg)</button>
            <button id="burn-prograde-btn">PROGRADE</button>
            <button id="burn-retrograde-btn">RETROGRADE</button>
            <button id="burn-normal-btn">NORMAL</button>
            <button id="burn-anti-normal-btn">ANTI-NORMAL</button>
            <button id="burn-radial-btn">RADIAL</button>
            <button id="burn-anti-radial-btn">ANTI-RADIAL</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Physical constants
        const G = 6.67430e-11;
        const EARTH_MASS = 5.972e24;
        const EARTH_RADIUS = 6.371e6;
        const EARTH_ROTATION = 7.2921159e-5;
        const KARMAN_LINE = 100000;
        const ATM_SCALE_HEIGHT = 8500;
        const SEA_LEVEL_PRESSURE = 101325;
        const SEA_LEVEL_DENSITY = 1.225;
        
        // Rocket configuration (Falcon 9-like)
        const ROCKET_CONFIG = {
            stages: [
                {
                    name: "Stage 1",
                    dryMass: 22200,
                    propellantMass: 395700,
                    thrust: 7607000,
                    thrustVac: 8227000,
                    isp: 282,
                    ispVac: 311,
                    diameter: 3.7,
                    length: 47,
                    dragCoeff: 0.3
                },
                {
                    name: "Stage 2",
                    dryMass: 4000,
                    propellantMass: 92670,
                    thrust: 981000,
                    thrustVac: 981000,
                    isp: 348,
                    ispVac: 348,
                    diameter: 3.7,
                    length: 14,
                    dragCoeff: 0.25
                }
            ],
            payload: 15000,
            fairingMass: 1700,
            fairingJettisonAlt: 110000,
            totalLength: 70
        };
        
        // Pitch program - 90° = pointing straight UP, 0° = pointing horizontal (east)
        const PITCH_PROGRAM = [
            { time: 0, pitch: 90 },
            { time: 10, pitch: 90 },
            { time: 20, pitch: 80 },
            { time: 40, pitch: 68 },
            { time: 60, pitch: 55 },
            { time: 80, pitch: 43 },
            { time: 100, pitch: 33 },
            { time: 120, pitch: 25 },
            { time: 150, pitch: 17 },
            { time: 180, pitch: 11 },
            { time: 220, pitch: 6 },
            { time: 280, pitch: 3 },
            { time: 400, pitch: 0 },
            { time: 600, pitch: 0 }
        ];
        
        let state = {
            running: false,
            time: 0,
            timeWarp: 1,
            x: 0,
            y: EARTH_RADIUS,
            vx: 0,
            vy: 0,
            currentStage: 0,
            propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
            fairingJettisoned: false,
            maxQ: 0,
            events: [],
            apoapsis: 0,
            periapsis: 0,
            engineOn: false,
            trail: [],
            manualZoom: 1.0,
            autoZoom: true,
            cameraMode: 'rocket', // 'rocket' or 'earth'
            burnMode: null, // null, 'prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'
            burnStartTime: null // Time when current burn started
        };
        
        const LAUNCH_LATITUDE = 28.5 * Math.PI / 180;
        
        function initState() {
            // Initialize rocket at pad position
            const x0 = 0;
            const y0 = EARTH_RADIUS;
            
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Rocket should start with this velocity so airspeed is ~0
            // Earth rotates counterclockwise (eastward)
            const atmVx0 = EARTH_ROTATION * y0;  // perpendicular to position vector (eastward)
            const atmVy0 = -EARTH_ROTATION * x0;
            
            state = {
                running: false,
                time: 0,
                timeWarp: 1,
                x: x0,
                y: y0,
                vx: atmVx0,  // Match atmospheric velocity so airspeed is ~0
                vy: atmVy0,
                currentStage: 0,
                propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
                fairingJettisoned: false,
                maxQ: 0,
                events: [],
                apoapsis: 0,
                periapsis: 0,
                engineOn: false,
                trail: [],
                manualZoom: 1.0,
                autoZoom: true,
                cameraMode: 'rocket', // 'rocket' or 'earth'
                burnMode: null, // null, 'prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'
                burnStartTime: null // Time when current burn started
            };
            
            document.getElementById('event-list').innerHTML = '';
        }
        
        function getTotalMass() {
            let mass = ROCKET_CONFIG.payload;
            if (!state.fairingJettisoned) mass += ROCKET_CONFIG.fairingMass;
            for (let i = state.currentStage; i < ROCKET_CONFIG.stages.length; i++) {
                mass += ROCKET_CONFIG.stages[i].dryMass + state.propellantRemaining[i];
            }
            return mass;
        }
        
        function getAltitude() {
            return Math.sqrt(state.x * state.x + state.y * state.y) - EARTH_RADIUS;
        }
        
        function getAtmosphericDensity(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_DENSITY * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getAtmosphericPressure(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_PRESSURE * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getGravity(r) {
            return G * EARTH_MASS / (r * r);
        }
        
        function getPitch(time) {
            for (let i = 0; i < PITCH_PROGRAM.length - 1; i++) {
                if (time >= PITCH_PROGRAM[i].time && time < PITCH_PROGRAM[i + 1].time) {
                    const t = (time - PITCH_PROGRAM[i].time) / (PITCH_PROGRAM[i + 1].time - PITCH_PROGRAM[i].time);
                    return PITCH_PROGRAM[i].pitch + t * (PITCH_PROGRAM[i + 1].pitch - PITCH_PROGRAM[i].pitch);
                }
            }
            return PITCH_PROGRAM[PITCH_PROGRAM.length - 1].pitch;
        }
        
        function getCurrentThrust(altitude) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            return stage.thrust * pressureRatio + stage.thrustVac * (1 - pressureRatio);
        }
        
        function getMassFlowRate(altitude) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            const isp = stage.isp * pressureRatio + stage.ispVac * (1 - pressureRatio);
            return getCurrentThrust(altitude) / (isp * 9.81);
        }
        
        function getAirspeed() {
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Earth rotates counterclockwise (eastward), so velocity is perpendicular to position vector
            const atmVx = EARTH_ROTATION * state.y;  // perpendicular to position vector (eastward)
            const atmVy = -EARTH_ROTATION * state.x;
            
            // Airspeed (velocity relative to atmosphere)
            const airVx = state.vx - atmVx;
            const airVy = state.vy - atmVy;
            const airspeed = Math.sqrt(airVx * airVx + airVy * airVy);
            
            return { airspeed, airVx, airVy };
        }
        
        function getDrag(altitude, airspeed) {
            if (state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            const density = getAtmosphericDensity(altitude);
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const area = Math.PI * (stage.diameter / 2) ** 2;
            return 0.5 * density * airspeed * airspeed * stage.dragCoeff * area;
        }
        
        function calculateOrbitalElements() {
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / r);
            const a = -mu / (2 * energy);
            const h = state.x * state.vy - state.y * state.vx;
            const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
            
            if (a > 0 && e < 1) {
                state.apoapsis = a * (1 + e) - EARTH_RADIUS;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
            } else {
                state.apoapsis = Infinity;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
            }
        }
        
        function addEvent(text) {
            const timeStr = formatTime(state.time);
            state.events.push({ time: timeStr, text });
            const eventList = document.getElementById('event-list');
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event';
            eventDiv.innerHTML = `<span class="event-time">T+${timeStr}</span> ${text}`;
            eventList.insertBefore(eventDiv, eventList.firstChild);
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }
        
        function update(dt) {
            if (!state.running) return;
            
            dt *= state.timeWarp;
            // Cap maximum timestep to prevent numerical instability at very high time warps
            // This ensures we don't try to integrate too far in one step
            const maxDt = 1.0; // Maximum 1 second per frame
            if (dt > maxDt) {
                dt = maxDt;
            }
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            if (r < EARTH_RADIUS && state.time > 1) {
                state.running = false;
                addEvent("MISSION FAILURE - Ground impact");
                return;
            }
            
            const mass = getTotalMass();
            
            // Gravity pointing toward Earth center
            const gravity = getGravity(r);
            const gx = -gravity * state.x / r;
            const gy = -gravity * state.y / r;
            
            // Local reference frame
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            
            // Calculate orbital directions if in orbit
            // Only allow burns after pitch program is complete (engine off, in orbit)
            let thrustDir;
            const pitchProgramComplete = state.time > 600 || (!state.engineOn && altitude > 150000);
            if (state.burnMode && pitchProgramComplete && altitude > 150000) {
                // Orbital burn mode - calculate direction based on burn type
                const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                const prograde = velocity > 0 ? { x: state.vx / velocity, y: state.vy / velocity } : { x: 0, y: 0 };
                const radial = localUp;
                const h = state.x * state.vy - state.y * state.vx; // Angular momentum
                const normal = h > 0 ? { x: -localUp.y, y: localUp.x } : { x: localUp.y, y: -localUp.x }; // Perpendicular to orbit plane
                
                switch (state.burnMode) {
                    case 'prograde':
                        thrustDir = prograde;
                        break;
                    case 'retrograde':
                        thrustDir = { x: -prograde.x, y: -prograde.y };
                        break;
                    case 'normal':
                        thrustDir = normal;
                        break;
                    case 'anti-normal':
                        thrustDir = { x: -normal.x, y: -normal.y };
                        break;
                    case 'radial':
                        thrustDir = radial;
                        break;
                    case 'anti-radial':
                        thrustDir = { x: -radial.x, y: -radial.y };
                        break;
                    default:
                        thrustDir = prograde;
                }
            } else {
                // Normal pitch program
                const pitchRad = getPitch(state.time) * Math.PI / 180;
                thrustDir = {
                    x: Math.sin(pitchRad) * localUp.x + Math.cos(pitchRad) * localEast.x,
                    y: Math.sin(pitchRad) * localUp.y + Math.cos(pitchRad) * localEast.y
                };
            }
            
            // Thrust - enable engine if in burn mode, pitch program complete, and have propellant
            if (state.burnMode && pitchProgramComplete && !state.engineOn && altitude > 150000 && 
                state.currentStage < ROCKET_CONFIG.stages.length && 
                state.propellantRemaining[state.currentStage] > 0) {
                state.engineOn = true;
            }
            
            const thrust = getCurrentThrust(altitude);
            const thrustAccel = thrust / mass;
            const tax = thrustAccel * thrustDir.x;
            const tay = thrustAccel * thrustDir.y;
            
            // Drag opposing airspeed (velocity relative to atmosphere)
            const { airspeed, airVx, airVy } = getAirspeed();
            const drag = getDrag(altitude, airspeed);
            const dragAccel = airspeed > 0 ? drag / mass : 0;
            const dax = airspeed > 0 ? -dragAccel * airVx / airspeed : 0;
            const day = airspeed > 0 ? -dragAccel * airVy / airspeed : 0;
            
            // Use adaptive sub-stepping for large timesteps to reduce integration errors
            // This is especially important in orbit where energy should be conserved
            // Use smaller steps in orbit to maintain accuracy
            const inOrbit = altitude > 150000 && !state.engineOn;
            const maxStepSize = inOrbit ? 0.01 : 0.05; // Smaller steps in orbit (10ms vs 50ms)
            const steps = Math.max(1, Math.ceil(dt / maxStepSize));
            const stepDt = dt / steps;
            
            // Limit maximum steps to prevent performance issues
            const maxSteps = 1000;
            const actualSteps = Math.min(steps, maxSteps);
            const actualStepDt = dt / actualSteps;
            
            for (let step = 0; step < actualSteps; step++) {
                // Recalculate forces at current position for each sub-step
                const rStep = Math.sqrt(state.x * state.x + state.y * state.y);
                const altitudeStep = rStep - EARTH_RADIUS;
                const velocityStep = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                
                // Gravity at current position
                const gravityStep = getGravity(rStep);
                const gxStep = -gravityStep * state.x / rStep;
                const gyStep = -gravityStep * state.y / rStep;
                
                // Thrust (recalculate if needed, but typically constant during step)
                const thrustStep = getCurrentThrust(altitudeStep);
                const thrustAccelStep = thrustStep / mass;
                const taxStep = thrustAccelStep * thrustDir.x;
                const tayStep = thrustAccelStep * thrustDir.y;
                
                // Drag at current position (using airspeed)
                // Earth rotates counterclockwise (eastward)
                const atmVxStep = EARTH_ROTATION * state.y;  // eastward
                const atmVyStep = -EARTH_ROTATION * state.x;
                const airVxStep = state.vx - atmVxStep;
                const airVyStep = state.vy - atmVyStep;
                const airspeedStep = Math.sqrt(airVxStep * airVxStep + airVyStep * airVyStep);
                const dragStep = getDrag(altitudeStep, airspeedStep);
                const dragAccelStep = airspeedStep > 0 ? dragStep / mass : 0;
                const daxStep = airspeedStep > 0 ? -dragAccelStep * airVxStep / airspeedStep : 0;
                const dayStep = airspeedStep > 0 ? -dragAccelStep * airVyStep / airspeedStep : 0;
                
                // Total acceleration
                const axStep = gxStep + taxStep + daxStep;
                const ayStep = gyStep + tayStep + dayStep;
                
                // Symplectic Euler integrator (conserves energy better than standard Euler)
                state.vx += axStep * actualStepDt;
                state.vy += ayStep * actualStepDt;
                state.x += state.vx * actualStepDt;
                state.y += state.vy * actualStepDt;
            }
            
            // Propellant consumption
            if (state.engineOn && state.currentStage < ROCKET_CONFIG.stages.length) {
                state.propellantRemaining[state.currentStage] -= getMassFlowRate(altitude) * dt;
                
                if (state.propellantRemaining[state.currentStage] <= 0) {
                    state.propellantRemaining[state.currentStage] = 0;
                    if (state.currentStage === 0) {
                        addEvent("MECO");
                        state.currentStage = 1;
                        addEvent("Stage separation");
                        addEvent("SES-1");
                    } else {
                        addEvent("SECO");
                        state.engineOn = false;
                        // Turn off burn mode when propellant runs out
                        if (state.burnMode) {
                            const burnNames = {
                                'prograde': 'PROGRADE',
                                'retrograde': 'RETROGRADE',
                                'normal': 'NORMAL',
                                'anti-normal': 'ANTI-NORMAL',
                                'radial': 'RADIAL',
                                'anti-radial': 'ANTI-RADIAL'
                            };
                            const duration = state.burnStartTime ? (state.time - state.burnStartTime).toFixed(1) : '0.0';
                            addEvent(`${burnNames[state.burnMode]} burn ended - out of propellant (${duration}s)`);
                            state.burnMode = null;
                            state.burnStartTime = null;
                        }
                    }
                }
            }
            
            // Turn off burn mode if engine turns off for any reason
            if (state.burnMode && !state.engineOn && state.burnStartTime !== null) {
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                const duration = (state.time - state.burnStartTime).toFixed(1);
                addEvent(`${burnNames[state.burnMode]} burn ended (${duration}s)`);
                state.burnMode = null;
                state.burnStartTime = null;
            }
            
            // Update burn duration
            if (state.burnMode && state.burnStartTime !== null) {
                // Burn duration is tracked, will be displayed in telemetry
            } else if (state.burnMode && state.burnStartTime === null) {
                // Just started burning
                state.burnStartTime = state.time;
            }
            
            if (!state.fairingJettisoned && altitude > ROCKET_CONFIG.fairingJettisonAlt) {
                state.fairingJettisoned = true;
                addEvent("Fairing jettison");
            }
            
            // Dynamic pressure using airspeed (velocity relative to atmosphere)
            const { airspeed: airspeedForQ } = getAirspeed();
            const dynPress = 0.5 * getAtmosphericDensity(altitude) * airspeedForQ * airspeedForQ;
            if (dynPress > state.maxQ) state.maxQ = dynPress;
            
            calculateOrbitalElements();
            
            // Add to trail more frequently and keep more points
            if (state.time % 0.1 < dt * state.timeWarp) {
                state.trail.push({ x: state.x, y: state.y });
                // Keep more trail points (10000 instead of 3000) so it doesn't disappear
                if (state.trail.length > 10000) state.trail.shift();
            }
            
            if (altitude >= KARMAN_LINE && !state.events.some(e => e.text.includes("Kármán"))) {
                addEvent("Kármán line - SPACE!");
            }
            
            state.time += dt;
            updateTelemetry();
        }
        
        function getNextEvent() {
            const altitude = getAltitude();
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const events = [];
            
            // Pitch program start (first pitch change at 10s)
            if (state.time < 10) {
                events.push({ time: 10 - state.time, name: 'Pitch program start' });
            }
            
            // Kármán line (100km)
            if (altitude < KARMAN_LINE && !state.events.some(e => e.text.includes("Kármán"))) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToKarman = (KARMAN_LINE - altitude) / vVert;
                    if (timeToKarman > 0 && timeToKarman < 10000) {
                        events.push({ time: timeToKarman, name: 'Kármán line' });
                    }
                }
            }
            
            // Fairing jettison (110km)
            if (!state.fairingJettisoned && altitude < ROCKET_CONFIG.fairingJettisonAlt) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToFairing = (ROCKET_CONFIG.fairingJettisonAlt - altitude) / vVert;
                    if (timeToFairing > 0 && timeToFairing < 10000) {
                        events.push({ time: timeToFairing, name: 'Fairing jettison' });
                    }
                }
            }
            
            // Stage separation (when stage 0 propellant runs out)
            if (state.currentStage === 0 && state.propellantRemaining[0] > 0 && state.engineOn) {
                const massFlowRate = getMassFlowRate(altitude);
                if (massFlowRate > 0) {
                    const timeToSeparation = state.propellantRemaining[0] / massFlowRate;
                    if (timeToSeparation > 0 && timeToSeparation < 10000) {
                        events.push({ time: timeToSeparation, name: 'Stage separation' });
                    }
                }
            }
            
            // Orbit (150km altitude and engine off) - only show if not yet in orbit
            const inOrbit = altitude >= 150000 && !state.engineOn;
            if (!inOrbit && altitude < 150000) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToOrbit = (150000 - altitude) / vVert;
                    if (timeToOrbit > 0 && timeToOrbit < 10000) {
                        // Also need engine to be off, so add time for propellant burn if needed
                        let totalTime = timeToOrbit;
                        if (state.engineOn && state.currentStage < ROCKET_CONFIG.stages.length) {
                            const massFlowRate = getMassFlowRate(altitude);
                            if (massFlowRate > 0 && state.propellantRemaining[state.currentStage] > 0) {
                                const timeToBurnout = state.propellantRemaining[state.currentStage] / massFlowRate;
                                totalTime = Math.max(timeToOrbit, timeToBurnout);
                            }
                        }
                        events.push({ time: totalTime, name: 'Orbit' });
                    }
                }
            }
            
            // SECO (when stage 1 propellant runs out)
            if (state.currentStage === 1 && state.propellantRemaining[1] > 0 && state.engineOn) {
                const massFlowRate = getMassFlowRate(altitude);
                if (massFlowRate > 0) {
                    const timeToSECO = state.propellantRemaining[1] / massFlowRate;
                    if (timeToSECO > 0 && timeToSECO < 10000) {
                        events.push({ time: timeToSECO, name: 'SECO' });
                    }
                }
            }
            
            // Return the event with the shortest time
            if (events.length > 0) {
                events.sort((a, b) => a.time - b.time);
                return events[0];
            }
            return null;
        }
        
        function formatTMinus(seconds) {
            if (seconds <= 0) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateTelemetry() {
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            const localUp = { x: state.x / r, y: state.y / r };
            const vVert = state.vx * localUp.x + state.vy * localUp.y;
            const vHoriz = Math.sqrt(Math.max(0, velocity * velocity - vVert * vVert));
            const downrange = Math.atan2(state.x, state.y) * EARTH_RADIUS;
            
            document.getElementById('time').textContent = formatTime(state.time);
            
            // Update T-minus countdown (central display)
            const nextEvent = getNextEvent();
            const tminusDisplay = document.getElementById('tminus-display');
            if (nextEvent && state.running && state.time > 0) {
                tminusDisplay.style.display = 'block';
                document.getElementById('tminus-time').textContent = 'T- ' + formatTMinus(nextEvent.time);
                document.getElementById('tminus-event-name').textContent = nextEvent.name.toUpperCase();
            } else {
                tminusDisplay.style.display = 'none';
            }
            document.getElementById('stage').textContent = state.currentStage + 1;
            document.getElementById('altitude').textContent = (altitude / 1000).toFixed(2) + ' km';
            document.getElementById('downrange').textContent = (downrange / 1000).toFixed(1) + ' km';
            document.getElementById('velocity').textContent = velocity.toFixed(0) + ' m/s';
            document.getElementById('vvel').textContent = vVert.toFixed(0) + ' m/s';
            document.getElementById('hvel').textContent = vHoriz.toFixed(0) + ' m/s';
            
            const thrust = getCurrentThrust(altitude);
            const mass = getTotalMass();
            document.getElementById('accel').textContent = (thrust / mass / 9.81).toFixed(2) + ' G';
            document.getElementById('maxq').textContent = (state.maxQ / 1000).toFixed(2) + ' kPa';
            const { airspeed: airspeedForDisplay } = getAirspeed();
            document.getElementById('dynpress').textContent = (0.5 * getAtmosphericDensity(altitude) * airspeedForDisplay * airspeedForDisplay / 1000).toFixed(2) + ' kPa';
            document.getElementById('mass').textContent = mass.toFixed(0) + ' kg';
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            if (stage) {
                document.getElementById('propellant').textContent = (state.propellantRemaining[state.currentStage] / stage.propellantMass * 100).toFixed(1) + '%';
            }
            document.getElementById('thrust').textContent = (thrust / 1000).toFixed(0) + ' kN';
            
            const pitch = getPitch(state.time);
            document.getElementById('pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('target-pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('current-pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('pitch-bar').style.width = (pitch / 90 * 100) + '%';
            
            document.getElementById('apoapsis').textContent = state.apoapsis === Infinity ? 'ESCAPE' : (state.apoapsis / 1000).toFixed(1) + ' km';
            document.getElementById('periapsis').textContent = (state.periapsis / 1000).toFixed(1) + ' km';
            
            // Show/hide burn controls when in orbit and pitch program is complete
            const pitchProgramComplete = state.time > 600 || (!state.engineOn && altitude > 150000);
            const inOrbit = altitude > 150000 && state.currentStage < ROCKET_CONFIG.stages.length && pitchProgramComplete;
            const burnControls = document.getElementById('burn-controls');
            if (inOrbit) {
                burnControls.style.display = 'block';
            } else {
                burnControls.style.display = 'none';
                // Clear burn mode if not in orbit or pitch program still running
                if (state.burnMode) {
                    state.burnMode = null;
                    state.burnStartTime = null;
                }
            }
            
            // Update active burn button and burn status
            const burnButtons = ['prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'];
            burnButtons.forEach(mode => {
                const btn = document.getElementById(`burn-${mode}-btn`);
                if (btn) {
                    if (state.burnMode === mode) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
            
            // Update burn status display
            const burnStatus = document.getElementById('burn-status');
            if (state.burnMode && state.burnStartTime !== null) {
                const burnDuration = state.time - state.burnStartTime;
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                burnStatus.innerHTML = `
                    <div style="color: #0ff; font-weight: bold;">BURNING: ${burnNames[state.burnMode]}</div>
                    <div style="color: #0f0;">Duration: ${burnDuration.toFixed(1)}s</div>
                `;
            } else {
                burnStatus.innerHTML = '<div>Hold button to burn</div>';
            }
        }
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const altitude = getAltitude();
            
            // ZOOM: Start at 2 m/px (very close), smoothly zoom out as altitude increases
            const minMPP = 2;
            // Allow zooming out to see full orbits (up to 20x Earth radius when following rocket)
            // No bounds when centered on Earth
            const maxMPP = state.cameraMode === 'earth' ? Infinity : (EARTH_RADIUS * 20 / Math.min(canvas.width, canvas.height));
            
            let autoMetersPerPixel;
            if (state.cameraMode === 'earth') {
                // When centered on Earth, use a default zoom that shows Earth nicely
                // Default to showing about 2x Earth radius
                const defaultEarthZoom = EARTH_RADIUS * 2.5 / Math.min(canvas.width, canvas.height);
                autoMetersPerPixel = defaultEarthZoom;
            } else if (altitude < 500) {
                autoMetersPerPixel = minMPP;
            } else {
                // Smooth logarithmic zoom - extend range for orbital viewing
                const zoomProgress = Math.min(1, Math.log10(altitude / 500) / 6);
                autoMetersPerPixel = minMPP * Math.pow(maxMPP / minMPP, zoomProgress);
            }
            
            // Apply manual zoom on top of auto zoom
            // In Earth mode, always use manual zoom (ignore autoZoom setting)
            const metersPerPixel = (state.cameraMode === 'earth' || !state.autoZoom) 
                ? autoMetersPerPixel / state.manualZoom 
                : autoMetersPerPixel / state.manualZoom;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 200; i++) {
                const sx = (Math.sin(i * 567.89 + 1000) * 0.5 + 0.5) * canvas.width;
                const sy = (Math.cos(i * 123.45 + 500) * 0.5 + 0.5) * canvas.height;
                ctx.fillRect(sx, sy, Math.random() > 0.85 ? 2 : 1, 1);
            }
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(1 / metersPerPixel, -1 / metersPerPixel);
             // Rotate 90 degrees counterclockwise
            
            // Camera: either follow rocket or center on Earth
            if (state.cameraMode === 'earth') {
                ctx.translate(0, 0); // Center on Earth (0, 0)
            } else {
                ctx.translate(-state.x, -state.y); // Follow rocket
            }
            
            // Earth
            ctx.beginPath();
            ctx.arc(0, 0, EARTH_RADIUS, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(-EARTH_RADIUS * 0.3, EARTH_RADIUS * 0.3, 0, 0, 0, EARTH_RADIUS);
            grad.addColorStop(0, '#3a7d32');
            grad.addColorStop(0.6, '#1a5a1a');
            grad.addColorStop(1, '#0a3a0a');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#2a8a2a';
            ctx.lineWidth = metersPerPixel * 2;
            ctx.stroke();
            
            // Ground detail when close
            if (metersPerPixel < 20) {
                ctx.fillStyle = '#555';
                ctx.fillRect(-30, EARTH_RADIUS - 1, 60, 2);
                ctx.fillStyle = '#777';
                ctx.fillRect(-25, EARTH_RADIUS, 4, 60);
            }
            
            // Atmosphere layers (when zoomed out)
            if (metersPerPixel > 50) {
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, EARTH_RADIUS + (i + 1) * 25000, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(100, 150, 255, ${0.1 - i * 0.02})`;
                    ctx.lineWidth = 20000;
                    ctx.stroke();
                }
            }
            
            // Karman line
            if (metersPerPixel > 200) {
                ctx.beginPath();
                ctx.arc(0, 0, EARTH_RADIUS + KARMAN_LINE, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.lineWidth = 1500;
                ctx.setLineDash([15000, 15000]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Trail - make it more visible and persistent
            if (state.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(state.trail[0].x, state.trail[0].y);
                for (let i = 1; i < state.trail.length; i++) {
                    ctx.lineTo(state.trail[i].x, state.trail[i].y);
                }
                ctx.strokeStyle = 'rgba(255, 120, 0, 0.8)';
                // Make trail thicker and more visible, especially when zoomed out
                ctx.lineWidth = Math.max(metersPerPixel * 2, 2);
                ctx.stroke();
            }
            
            // Rocket - ACTUAL SIZE 70m x 3.7m
            const rocketLen = 70;
            const rocketWid = 3.7;
            
            ctx.save();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            // Move rocket up by half its length so it sits on top of the pad
            ctx.translate(state.x + localUp.x * rocketLen * 0.5, state.y + localUp.y * rocketLen * 0.5);
            const pitchRad = getPitch(state.time) * Math.PI / 180;
            
            // Calculate thrust direction vector
            const thrustDir = {
                x: Math.sin(pitchRad) * localUp.x + Math.cos(pitchRad) * localEast.x,
                y: Math.sin(pitchRad) * localUp.y + Math.cos(pitchRad) * localEast.y
            };
            
            // Rocket angle: point rocket nose (at negative Y in drawing coords) in thrust direction
            // Since canvas Y is flipped, negative Y in drawing = positive Y on screen (up)
            // Add π/2 offset to correct for 90° counter-clockwise misalignment
            const rocketAngle = Math.atan2(thrustDir.y, thrustDir.x) - Math.PI / 2;
            ctx.rotate(rocketAngle);
            
            // Make rocket visible even when zoomed out
            const minPixelSize = 12;
            const scale = Math.max(1, minPixelSize * metersPerPixel / rocketLen);
            const drawLen = rocketLen * scale;
            const drawWid = rocketWid * scale;
            
            // Body
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(-drawWid/2, -drawLen * 0.4, drawWid, drawLen * 0.8);
            
            // Nose (at positive Y to point in thrust direction)
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, drawLen * 0.4);
            ctx.lineTo(0, drawLen * 0.55);
            ctx.lineTo(drawWid/2, drawLen * 0.4);
            ctx.fillStyle = '#d33';
            ctx.fill();
            
            // Fins (at negative Y, engine end)
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, -drawLen * 0.35);
            ctx.lineTo(-drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(-drawWid/2, -drawLen * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(drawWid/2, -drawLen * 0.35);
            ctx.lineTo(drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(drawWid/2, -drawLen * 0.2);
            ctx.fill();
            
            // Flame (at negative Y, engine end)
            if (state.engineOn && state.propellantRemaining[state.currentStage] > 0) {
                const flameLen = drawLen * (0.5 + Math.random() * 0.25);
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.2, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, 0, -drawLen * 0.4 - flameLen);
                ctx.quadraticCurveTo(drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, drawWid * 0.2, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${80 + Math.random() * 60}, 0)`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.1, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, 0, -drawLen * 0.4 - flameLen * 0.6);
                ctx.quadraticCurveTo(drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, drawWid * 0.1, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${200 + Math.random() * 55}, ${100 + Math.random() * 80})`;
                ctx.fill();
            }
            
            ctx.restore(); // Restore rocket rotation
            
            // Draw thrust vector arrow
            if (state.engineOn && state.propellantRemaining[state.currentStage] > 0) {
                const arrowLength = 100; // meters
                const arrowHeadSize = 12; // meters
                
                ctx.save();
                const rArrow = Math.sqrt(state.x * state.x + state.y * state.y);
                const localUpArrow = { x: state.x / rArrow, y: state.y / rArrow };
                // Position arrow at same location as rocket (offset by half rocket length)
                ctx.translate(state.x + localUpArrow.x * rocketLen * 0.5, state.y + localUpArrow.y * rocketLen * 0.5);
                
                // Draw arrow line in thrust direction
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(thrustDir.x * arrowLength, thrustDir.y * arrowLength);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = metersPerPixel * 3;
                ctx.stroke();
                
                // Draw arrowhead (pointing forward in thrust direction)
                const arrowX = thrustDir.x * arrowLength;
                const arrowY = thrustDir.y * arrowLength;
                const arrowAngle = Math.atan2(thrustDir.y, thrustDir.x);
                
                // Arrowhead: tip is at the end of the arrow, base is slightly back
                const tipX = arrowX;
                const tipY = arrowY;
                const baseOffset = arrowHeadSize * 0.8;
                const baseX = arrowX - baseOffset * Math.cos(arrowAngle);
                const baseY = arrowY - baseOffset * Math.sin(arrowAngle);
                const wingOffset = arrowHeadSize * 0.5;
                
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(
                    baseX + wingOffset * Math.cos(arrowAngle + Math.PI / 2),
                    baseY + wingOffset * Math.sin(arrowAngle + Math.PI / 2)
                );
                ctx.lineTo(
                    baseX + wingOffset * Math.cos(arrowAngle - Math.PI / 2),
                    baseY + wingOffset * Math.sin(arrowAngle - Math.PI / 2)
                );
                ctx.closePath();
                ctx.fillStyle = '#0ff';
                ctx.fill();
                
                ctx.restore();
            }
            
            // Orbit prediction - draw before restoring coordinate transform
            // Always show when in orbit (elliptical or circular)
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / r);
            if (altitude > 10000 && energy < 0) {
                const a = -mu / (2 * energy);
                const h = state.x * state.vy - state.y * state.vx;
                const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
                if (e < 1 && a > 0 && a < EARTH_RADIUS * 50 && e > 0.001) {
                    // Calculate orbit orientation using eccentricity vector (more stable)
                    const v2 = v * v;
                    const rVec = { x: state.x, y: state.y };
                    const vVec = { x: state.vx, y: state.vy };
                    
                    // Eccentricity vector points toward periapsis
                    const rDotV = rVec.x * vVec.x + rVec.y * vVec.y;
                    const eVec = {
                        x: ((v2 - mu / r) * rVec.x - rDotV * vVec.x) / mu,
                        y: ((v2 - mu / r) * rVec.y - rDotV * vVec.y) / mu
                    };
                    
                    // Argument of periapsis (angle of periapsis from reference direction)
                    const periapsisAngle = Math.atan2(eVec.y, eVec.x);
                    
                    // Current true anomaly - verify it matches current position
                    const rDotE = rVec.x * eVec.x + rVec.y * eVec.y;
                    const cosNu = Math.max(-1, Math.min(1, rDotE / (r * e)));
                    const rDotVNorm = rDotV / Math.sqrt(mu * a);
                    const sinNu = Math.max(-1, Math.min(1, rDotVNorm / e));
                    const nu = Math.atan2(sinNu, cosNu);
                    
                    // Verify: current position should be at periapsisAngle + nu
                    // So orbit is drawn with periapsis at periapsisAngle
                    const theta0 = periapsisAngle;
                    
                    ctx.beginPath();
                    let firstPoint = true;
                    let lastValidPoint = null;
                    for (let ang = 0; ang <= Math.PI * 2 + 0.05; ang += 0.01) {
                        const rOrb = a * (1 - e * e) / (1 + e * Math.cos(ang));
                        if (rOrb > EARTH_RADIUS && rOrb < EARTH_RADIUS * 50 && isFinite(rOrb)) {
                            const xO = rOrb * Math.cos(ang + theta0);
                            const yO = rOrb * Math.sin(ang + theta0);
                            if (isFinite(xO) && isFinite(yO)) {
                                if (firstPoint) {
                                    ctx.moveTo(xO, yO);
                                    firstPoint = false;
                                    lastValidPoint = { x: xO, y: yO };
                                } else {
                                    // Only draw if point is reasonable (not a huge jump)
                                    if (lastValidPoint) {
                                        const dx = xO - lastValidPoint.x;
                                        const dy = yO - lastValidPoint.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < EARTH_RADIUS * 10) { // Reasonable step size
                                            ctx.lineTo(xO, yO);
                                            lastValidPoint = { x: xO, y: yO };
                                        }
                                    } else {
                                        ctx.lineTo(xO, yO);
                                        lastValidPoint = { x: xO, y: yO };
                                    }
                                }
                            }
                        }
                    }
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                    ctx.lineWidth = Math.max(metersPerPixel * 3, 2);
                    ctx.setLineDash([metersPerPixel * 20, metersPerPixel * 10]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.restore(); // Restore coordinate transform
            ctx.restore();
            
            // Info
            ctx.fillStyle = '#555';
            ctx.font = '11px Courier New';
            ctx.fillText(`${metersPerPixel < 1000 ? metersPerPixel.toFixed(1) + ' m/px' : (metersPerPixel/1000).toFixed(2) + ' km/px'}`, 10, canvas.height - 10);
        }
        
        let lastTime = 0;
        function loop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            update(dt);
            render();
            requestAnimationFrame(loop);
        }
        
        document.getElementById('launch-btn').addEventListener('click', () => {
            if (!state.running && state.time === 0) {
                state.running = true;
                state.engineOn = true;
                addEvent("LIFTOFF!");
                document.getElementById('launch-btn').disabled = true;
                document.getElementById('launch-btn').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'inline-block';
            }
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            if (state.running) {
                state.running = false;
                document.getElementById('pause-btn').textContent = 'RESUME';
                addEvent("PAUSED");
            } else {
                state.running = true;
                document.getElementById('pause-btn').textContent = 'PAUSE';
                addEvent("RESUMED");
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('pause-btn').textContent = 'PAUSE';
            updateTelemetry();
        });
        
        const speeds = [1, 2, 5, 10, 25, 50, 100, 500, 1000];
        let speedIdx = 0;
        document.getElementById('speed-btn').addEventListener('click', () => {
            speedIdx = (speedIdx + 1) % speeds.length;
            state.timeWarp = speeds[speedIdx];
            document.getElementById('speed-btn').textContent = speeds[speedIdx] + 'x';
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            state.manualZoom /= 2.0;
            if (state.manualZoom < 0.1) state.manualZoom = 0.1;
        });
        
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            state.manualZoom *= 2.0;
            // No upper bound when centered on Earth
            if (state.cameraMode === 'rocket' && state.manualZoom > 10000) state.manualZoom = 10000;
        });
        
        document.getElementById('zoom-auto-btn').addEventListener('click', () => {
            state.autoZoom = !state.autoZoom;
            document.getElementById('zoom-auto-btn').textContent = state.autoZoom ? 'AUTO ZOOM' : 'MANUAL ZOOM';
            if (!state.autoZoom) {
                state.manualZoom = 1.0; // Reset manual zoom when switching to auto
            }
        });
        
        document.getElementById('camera-btn').addEventListener('click', () => {
            state.cameraMode = state.cameraMode === 'rocket' ? 'earth' : 'rocket';
            document.getElementById('camera-btn').textContent = state.cameraMode === 'rocket' ? 'FOLLOW ROCKET' : 'CENTER EARTH';
            // Reset zoom to reasonable default when switching to Earth mode
            if (state.cameraMode === 'earth') {
                state.manualZoom = 1.0;
                state.autoZoom = false; // Disable auto zoom in Earth mode
            }
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Scroll down (deltaY > 0) should zoom out, scroll up (deltaY < 0) should zoom in
            const zoomFactor = e.deltaY > 0 ? 1/1.3 : 1.3;
            state.manualZoom *= zoomFactor;
            if (state.manualZoom < 0.1) state.manualZoom = 0.1;
            // No upper bound when centered on Earth
            if (state.cameraMode === 'rocket' && state.manualZoom > 10000) state.manualZoom = 10000;
        });
        
        // Burn control buttons - hold to burn
        let activeBurnButton = null;
        
        function stopBurn() {
            if (state.burnMode && state.burnStartTime !== null) {
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                const duration = (state.time - state.burnStartTime).toFixed(1);
                addEvent(`${burnNames[state.burnMode]} burn ended (${duration}s)`);
                state.burnMode = null;
                state.burnStartTime = null;
                state.engineOn = false; // Turn off engine when burn ends
                activeBurnButton = null;
            }
        }
        
        function setupBurnButton(buttonId, burnMode) {
            const btn = document.getElementById(buttonId);
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const pitchProgramComplete = state.time > 600 || (!state.engineOn && getAltitude() > 150000);
                if (pitchProgramComplete && getAltitude() > 150000) {
                    // Stop any existing burn
                    if (state.burnMode) {
                        stopBurn();
                    }
                    state.burnMode = burnMode;
                    state.burnStartTime = state.time;
                    activeBurnButton = btn;
                    addEvent(`${burnMode.toUpperCase()} burn started`);
                }
            });
            btn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                if (state.burnMode === burnMode) {
                    stopBurn();
                }
            });
            btn.addEventListener('mouseleave', () => {
                if (state.burnMode === burnMode && activeBurnButton === btn) {
                    stopBurn();
                }
            });
        }
        
        // Global mouseup listener to catch mouse release anywhere
        document.addEventListener('mouseup', () => {
            if (state.burnMode && activeBurnButton) {
                stopBurn();
            }
        });
        
        setupBurnButton('burn-prograde-btn', 'prograde');
        setupBurnButton('burn-retrograde-btn', 'retrograde');
        setupBurnButton('burn-normal-btn', 'normal');
        setupBurnButton('burn-anti-normal-btn', 'anti-normal');
        setupBurnButton('burn-radial-btn', 'radial');
        setupBurnButton('burn-anti-radial-btn', 'anti-radial');
        
        // Refuel button - adds propellant for orbital maneuvers
        document.getElementById('refuel-btn').addEventListener('click', () => {
            if (state.currentStage < ROCKET_CONFIG.stages.length) {
                const refuelAmount = 5000; // kg
                state.propellantRemaining[state.currentStage] += refuelAmount;
                // Cap at original propellant mass
                if (state.propellantRemaining[state.currentStage] > ROCKET_CONFIG.stages[state.currentStage].propellantMass) {
                    state.propellantRemaining[state.currentStage] = ROCKET_CONFIG.stages[state.currentStage].propellantMass;
                }
                addEvent(`Refueled: +${refuelAmount} kg propellant`);
            }
        });
        
        initState();
        updateTelemetry();
        requestAnimationFrame(loop);
    </script>
</body>
</html>