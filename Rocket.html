<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Rocket Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
        }
        
        #canvas {
            background: #000;
        }
        
        #telemetry {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-size: 13px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
            min-width: 280px;
        }
        
        #telemetry h3 {
            color: #0ff;
            margin-bottom: 10px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }
        
        .section {
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .label {
            color: #888;
        }
        
        .value {
            color: #0f0;
            float: right;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #events {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #0ff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 5px;
            max-width: 250px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #burn-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 5px;
            min-width: 150px;
        }
        
        #burn-controls button {
            width: 100%;
            padding: 8px;
            font-size: 11px;
        }
        
        #burn-controls button.active {
            background: #0ff;
            color: #000;
        }
        
        #events h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }
        
        .event {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #333;
            font-size: 11px;
        }
        
        .event-time {
            color: #888;
        }
        
        #pitch-program {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #f80;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 1px solid #f80;
            border-radius: 5px;
            width: 200px;
        }
        
        #pitch-program h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #f80;
            padding-bottom: 5px;
        }
        
        .pitch-bar {
            width: 100%;
            height: 20px;
            background: #333;
            margin-top: 10px;
            position: relative;
        }
        
        .pitch-indicator {
            height: 100%;
            background: linear-gradient(90deg, #f80, #ff0);
            transition: width 0.1s;
        }
        
        #tminus-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border: 2px solid #0ff;
            border-radius: 5px;
            text-align: center;
            display: none;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        #tminus-display .tminus-time {
            font-size: 32px;
            color: #0ff;
            margin-bottom: 5px;
        }
        
        #tminus-display .tminus-event {
            font-size: 14px;
            color: #0f0;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="tminus-display">
        <div class="tminus-time" id="tminus-time">T- 00:00</div>
        <div class="tminus-event" id="tminus-event-name">Next Event</div>
    </div>
    
    <div id="telemetry">
        <h3>TELEMETRY</h3>
        <div class="section">
            <div><span class="label">T+</span><span class="value" id="time">00:00:00</span></div>
            <div><span class="label">Stage</span><span class="value" id="stage">1</span></div>
        </div>
        <div class="section">
            <div><span class="label">Altitude</span><span class="value" id="altitude">0 km</span></div>
            <div><span class="label">Downrange</span><span class="value" id="downrange">0 km</span></div>
            <div><span class="label">Velocity</span><span class="value" id="velocity">0 m/s</span></div>
            <div><span class="label">Vertical V</span><span class="value" id="vvel">0 m/s</span></div>
            <div><span class="label">Horizontal V</span><span class="value" id="hvel">0 m/s</span></div>
        </div>
        <div class="section">
            <div><span class="label">Acceleration</span><span class="value" id="accel">0 G</span></div>
            <div><span class="label">Max Q</span><span class="value" id="maxq">0 kPa</span></div>
            <div><span class="label">Dynamic Press</span><span class="value" id="dynpress">0 kPa</span></div>
        </div>
        <div class="section">
            <div><span class="label">Mass</span><span class="value" id="mass">0 kg</span></div>
            <div><span class="label">Propellant</span><span class="value" id="propellant">0%</span></div>
            <div><span class="label">Thrust</span><span class="value" id="thrust">0 kN</span></div>
        </div>
        <div class="section">
            <div><span class="label">Pitch</span><span class="value" id="pitch">90°</span></div>
            <div><span class="label">Apoapsis</span><span class="value" id="apoapsis">0 km</span></div>
            <div><span class="label">Periapsis</span><span class="value" id="periapsis">0 km</span></div>
        </div>
    </div>
    
    <div id="events">
        <h3>MISSION EVENTS</h3>
        <div id="event-list"></div>
    </div>
    
    <div id="pitch-program">
        <h3>PITCH PROGRAM</h3>
        <div><span class="label">Target:</span> <span id="target-pitch">90°</span></div>
        <div><span class="label">Current:</span> <span id="current-pitch">90°</span></div>
        <div class="pitch-bar">
            <div class="pitch-indicator" id="pitch-bar"></div>
        </div>
    </div>
    
    <div id="controls">
        <button id="launch-btn">LAUNCH</button>
        <button id="pause-btn" style="display: none;">PAUSE</button>
        <button id="reset-btn">RESET</button>
        <button id="speed-btn">1x</button>
        <button id="zoom-out-btn">ZOOM OUT</button>
        <button id="zoom-in-btn">ZOOM IN</button>
        <button id="zoom-auto-btn">AUTO ZOOM</button>
        <button id="camera-btn">FOLLOW ROCKET</button>
    </div>
    
    <div id="burn-controls" style="display: none;">
        <h3 style="color: #0ff; margin-bottom: 10px;">ORBITAL BURNS</h3>
        <div id="burn-status" style="color: #0f0; font-size: 11px; margin-bottom: 10px; min-height: 30px;">
            <div>Hold button to burn</div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <button id="refuel-btn" style="background: #2a2; border-color: #2a2; margin-bottom: 5px;">REFUEL (5000 kg)</button>
            <button id="burn-prograde-btn">PROGRADE</button>
            <button id="burn-retrograde-btn">RETROGRADE</button>
            <button id="burn-normal-btn">NORMAL</button>
            <button id="burn-anti-normal-btn">ANTI-NORMAL</button>
            <button id="burn-radial-btn">RADIAL</button>
            <button id="burn-anti-radial-btn">ANTI-RADIAL</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Physical constants
        const G = 6.67430e-11;
        const EARTH_MASS = 5.972e24;
        const EARTH_RADIUS = 6.371e6;
        const EARTH_ROTATION = 7.2921159e-5;
        const KARMAN_LINE = 100000;
        const ATM_SCALE_HEIGHT = 8500;
        const SEA_LEVEL_PRESSURE = 101325;
        const SEA_LEVEL_DENSITY = 1.225;
        
        // Rocket configuration (Falcon 9-like)
        const ROCKET_CONFIG = {
            stages: [
                {
                    name: "Stage 1",
                    dryMass: 22200,
                    propellantMass: 395700,
                    thrust: 7607000,
                    thrustVac: 8227000,
                    isp: 282,
                    ispVac: 311,
                    diameter: 3.7,
                    length: 47,
                    dragCoeff: 0.3
                },
                {
                    name: "Stage 2",
                    dryMass: 4000,
                    propellantMass: 92670,
                    thrust: 981000,
                    thrustVac: 981000,
                    isp: 348,
                    ispVac: 348,
                    diameter: 3.7,
                    length: 14,
                    dragCoeff: 0.25
                }
            ],
            payload: 15000,
            fairingMass: 1700,
            fairingJettisonAlt: 110000,
            totalLength: 70
        };
        
        
        
        // ============================================================================
        // CLOSED-LOOP GUIDANCE SYSTEM v3
        // ============================================================================
        // 
        // V3 PHILOSOPHY: Simple, priority-based guidance that focuses on what matters
        // when it matters. In atmosphere, we DON'T optimize for orbit - we escape.
        // Above atmosphere, we optimize for target orbit.
        //
        // PRIORITY SYSTEM:
        //   1. HEIGHT      — Get above 70km (out of significant atmosphere)
        //   2. MAX Q       — Don't exceed structural limits, follow prograde in atmo
        //   3. ANGLE       — Correct orbit shape (apoapsis/periapsis) - ONLY above 70km
        //   4. VELOCITY    — Throttle down near end to hit target precisely
        //
        // KEY INSIGHT: Don't try to optimize trajectory in atmosphere.
        // Get high, get fast, THEN correct.
        //
        // ATMOSPHERIC PHASE (below 70km):
        //   - Follow prograde (minimizes angle of attack and drag)
        //   - Smooth altitude-based minimum pitch constraint (prevents premature pitchover)
        //   - Turn rate limiting (prevents gravity turn from running away)
        //   - Max Q protection (follow prograde exactly when near structural limits)
        //
        // VACUUM PHASE (above 70km):
        //   - Active closed-loop guidance to reach target orbit
        //   - Adjusts pitch based on apoapsis/periapsis errors
        //   - Throttle control for precise orbit insertion
        //
        // ============================================================================
        const GUIDANCE_CONFIG = {
            // Target orbit
            targetAltitude: 400000,          // meters — target circular orbit
            
            // Atmosphere threshold
            atmosphereLimit: 70000,          // meters — above this, we're in "vacuum"
            
            // Max Q protection
            maxQ: 35000,                     // Pa — typical max Q for Falcon 9 ~32-35 kPa
            
            // Pitch constraints
            maxPitchCorrection: 10,          // degrees — max deviation from prograde in vacuum
            maxPitchRate: 2.0,               // degrees/second — physical rotation limit
            
            // Throttle control
            throttleDownMargin: 1.15,        // Start throttling when deltaV reserve > 115% needed
            minThrottle: 0.4,                // Don't throttle below 40%
            
            // Initial ascent
            initialPitch: 85,                // degrees — slight eastward tilt from start
            pitchKickStart: 3,               // seconds — when to start pitching from vertical
            pitchKickEnd: 15,                // seconds — when to reach initialPitch
        };
        
        let guidanceState = {
            phase: 'pre-launch',
            lastCommandedPitch: 90,
            throttle: 1.0,
            lastFlightPathAngle: 90,
        };
        
        function resetGuidance() {
            guidanceState = {
                phase: 'pre-launch',
                lastCommandedPitch: 90,
                throttle: 1.0,
                lastFlightPathAngle: 90,
            };
        }
        
        // ============================================================================
        // HELPER: Predict orbit from current state (vacuum assumption)
        // ============================================================================
        function predictOrbit(state) {
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            
            // Specific orbital energy: ε = v²/2 - μ/r
            const energy = (v * v / 2) - (mu / r);
            
            // Semi-major axis: a = -μ/(2ε)
            // If energy ≥ 0, we're on escape trajectory
            if (energy >= 0) {
                return {
                    apoapsis: Infinity,
                    periapsis: r - EARTH_RADIUS,
                    semiMajorAxis: Infinity,
                    eccentricity: 1,
                    energy: energy,
                    isEscape: true
                };
            }
            
            const semiMajorAxis = -mu / (2 * energy);
            
            // Angular momentum: h = r × v (magnitude in 2D)
            const angularMomentum = state.x * state.vy - state.y * state.vx;
            
            // Eccentricity: e = √(1 + 2εh²/μ²)
            const eSquared = 1 + (2 * energy * angularMomentum * angularMomentum) / (mu * mu);
            const eccentricity = Math.sqrt(Math.max(0, eSquared));
            
            // Apoapsis and periapsis
            const apoapsis = semiMajorAxis * (1 + eccentricity) - EARTH_RADIUS;
            const periapsis = semiMajorAxis * (1 - eccentricity) - EARTH_RADIUS;
            
            return {
                apoapsis: apoapsis,
                periapsis: periapsis,
                semiMajorAxis: semiMajorAxis,
                eccentricity: eccentricity,
                energy: energy,
                angularMomentum: angularMomentum,
                isEscape: false
            };
        }
        
        // ============================================================================
        // HELPER: Compute remaining delta-v from propellant (Tsiolkovsky equation)
        // ============================================================================
        function computeRemainingDeltaV(state) {
            // Δv = Isp × g₀ × ln(m_initial / m_final)
            
            const g0 = 9.81;
            let totalDeltaV = 0;
            
            // Current stage
            if (state.currentStage < ROCKET_CONFIG.stages.length) {
                const stage = ROCKET_CONFIG.stages[state.currentStage];
                const propellant = state.propellantRemaining[state.currentStage];
                
                if (propellant > 0) {
                    // Mass at start of current burn
                    let massInitial = ROCKET_CONFIG.payload;
                    if (!state.fairingJettisoned) massInitial += ROCKET_CONFIG.fairingMass;
                    
                    // Add current stage
                    massInitial += stage.dryMass + propellant;
                    
                    // Add future stages
                    for (let i = state.currentStage + 1; i < ROCKET_CONFIG.stages.length; i++) {
                        massInitial += ROCKET_CONFIG.stages[i].dryMass + state.propellantRemaining[i];
                    }
                    
                    // Mass at end (after burning current stage propellant)
                    const massFinal = massInitial - propellant;
                    
                    // Use vacuum Isp (we're mostly concerned with vacuum performance)
                    const isp = stage.ispVac;
                    
                    // Tsiolkovsky rocket equation
                    totalDeltaV += isp * g0 * Math.log(massInitial / massFinal);
                }
            }
            
            // Future stages (full burns)
            for (let i = state.currentStage + 1; i < ROCKET_CONFIG.stages.length; i++) {
                const stage = ROCKET_CONFIG.stages[i];
                const propellant = state.propellantRemaining[i];
                
                if (propellant > 0) {
                    // Mass at start of this stage's burn
                    let massInitial = ROCKET_CONFIG.payload;
                    // Fairing should be jettisoned by upper stage
                    massInitial += stage.dryMass + propellant;
                    
                    // Add any stages after this
                    for (let j = i + 1; j < ROCKET_CONFIG.stages.length; j++) {
                        massInitial += ROCKET_CONFIG.stages[j].dryMass + state.propellantRemaining[j];
                    }
                    
                    const massFinal = massInitial - propellant;
                    const isp = stage.ispVac;
                    
                    totalDeltaV += isp * g0 * Math.log(massInitial / massFinal);
                }
            }
            
            return totalDeltaV;
        }
        
        // ============================================================================
        // HELPER: Compute total delta-v at launch (for progress tracking)
        // ============================================================================
        function computeInitialDeltaV() {
            const g0 = 9.81;
            let totalDeltaV = 0;
            
            for (let i = 0; i < ROCKET_CONFIG.stages.length; i++) {
                const stage = ROCKET_CONFIG.stages[i];
                const propellant = stage.propellantMass;
                
                // Mass at start of this stage
                let massInitial = ROCKET_CONFIG.payload + ROCKET_CONFIG.fairingMass;
                massInitial += stage.dryMass + propellant;
                
                for (let j = i + 1; j < ROCKET_CONFIG.stages.length; j++) {
                    massInitial += ROCKET_CONFIG.stages[j].dryMass + ROCKET_CONFIG.stages[j].propellantMass;
                }
                
                const massFinal = massInitial - propellant;
                
                // Use vacuum Isp for simplicity (slight overestimate for stage 1)
                const isp = stage.ispVac;
                
                totalDeltaV += isp * g0 * Math.log(massInitial / massFinal);
            }
            
            return totalDeltaV;
        }
        
        // ============================================================================
        // MAIN GUIDANCE FUNCTION
        // ============================================================================
        function computeGuidance(state, dt) {
            
            // ========================================================================
            // STEP 1: GATHER CURRENT STATE
            // ========================================================================
            
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const altitude = r - EARTH_RADIUS;
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            // Local reference frame (changes as we move around Earth)
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            
            // Decompose velocity into vertical and horizontal components
            const vVertical = state.vx * localUp.x + state.vy * localUp.y;
            const vHorizontal = state.vx * localEast.x + state.vy * localEast.y;
            
            // Flight path angle (angle of velocity from horizontal)
            // 90° = straight up, 0° = horizontal, negative = descending
            const flightPathAngle = Math.atan2(vVertical, vHorizontal) * 180 / Math.PI;
            
            // Dynamic pressure (for max Q check)
            const airDensity = getAtmosphericDensity(altitude);
            const { airspeed } = getAirspeed();
            const dynamicPressure = 0.5 * airDensity * airspeed * airspeed;
            
            // ========================================================================
            // STEP 2: PREDICT ORBIT (vacuum assumption)
            // ========================================================================
            // "If I cut engines right now, what orbit am I on?"
            
            const orbit = predictOrbit(state);
            
            // ========================================================================
            // STEP 3: COMPUTE TARGET PARAMETERS
            // ========================================================================
            
            // Circular orbit velocity at target altitude
            const targetRadius = EARTH_RADIUS + GUIDANCE_CONFIG.targetAltitude;
            const mu = G * EARTH_MASS;
            const vCircular = Math.sqrt(mu / targetRadius);
            
            // How much more horizontal velocity do we need?
            const velocityDeficit = vCircular - vHorizontal;
            
            // Remaining delta-v from propellant
            const remainingDeltaV = computeRemainingDeltaV(state);
            
            // ========================================================================
            // STEP 4: PRIORITY-BASED GUIDANCE LOGIC
            // ========================================================================
            
            let commandedPitch;
            let commandedThrottle = 1.0;
            let phase;
            let debugInfo = {};
            
            // ------------------------------------------------------------------------
            // PRIORITY 1: HEIGHT — Get out of atmosphere
            // ------------------------------------------------------------------------
            
            if (altitude < GUIDANCE_CONFIG.atmosphereLimit) {
                
                // Sub-case: Very early flight (first few seconds)
                if (state.time < GUIDANCE_CONFIG.pitchKickStart) {
                    phase = 'vertical-ascent';
                    commandedPitch = 90;
                    debugInfo.reason = 'Clearing pad — vertical';
                }
                
                // Sub-case: Pitch kick (gradual tilt to start gravity turn)
                else if (state.time < GUIDANCE_CONFIG.pitchKickEnd) {
                    phase = 'pitch-kick';
                    const progress = (state.time - GUIDANCE_CONFIG.pitchKickStart) / 
                                   (GUIDANCE_CONFIG.pitchKickEnd - GUIDANCE_CONFIG.pitchKickStart);
                    // Smooth cosine interpolation
                    const smoothProgress = (1 - Math.cos(progress * Math.PI)) / 2;
                    commandedPitch = 90 - smoothProgress * (90 - GUIDANCE_CONFIG.initialPitch);
                    debugInfo.reason = 'Pitch kick — initiating gravity turn';
                }
                
                // Sub-case: In atmosphere, past pitch kick
                else {
                    // ============================================================
                    // ATMOSPHERIC PHASE — PRIORITY IS ESCAPE, NOT ORBIT SHAPING
                    // ============================================================
                    //
                    // In atmosphere, we DO NOT care about:
                    //   - Target orbit
                    //   - Apoapsis/periapsis predictions
                    //   - Circularization
                    //
                    // We ONLY care about:
                    //   1. Not exceeding max Q (structural protection)
                    //   2. Getting out of atmosphere efficiently
                    //   3. Not turning so fast we nosedive
                    //
                    // The strategy: Follow prograde (minimizes angle of attack and drag)
                    // but prevent the turn from running away by limiting turn rate.
                    // ============================================================
                    
                    // PRIORITY 2: MAX Q — Protect structure
                    if (dynamicPressure > GUIDANCE_CONFIG.maxQ * 0.8) {
                        phase = 'max-q-protection';
                        commandedPitch = flightPathAngle;
                        debugInfo.reason = 'Max Q — following prograde exactly';
                        debugInfo.q = dynamicPressure;
                    }
                    else {
                        phase = 'atmospheric-ascent';
                        
                        // ============================================================
                        // ALTITUDE-BASED MINIMUM PITCH CONSTRAINT
                        // ============================================================
                        // 
                        // WHY: At low altitudes, the rocket MUST stay nearly vertical
                        // to build altitude efficiently. Without this constraint, following
                        // prograde alone can cause the rocket to pitch over too aggressively,
                        // leading to insufficient altitude gain.
                        //
                        // HOW: Use a smooth, continuous quadratic function to define minimum
                        // pitch as a function of altitude. This avoids discontinuities that
                        // would cause sudden pitch changes at altitude boundaries.
                        //
                        // CURVE: 90° at 0km → ~75° at 30km → ~64° at 40km → ~10° at 70km
                        // Formula: minPitch = 90 - (altitude/70km)² * 80
                        //
                        // IMPLEMENTATION: Soft constraint - gently encourages higher pitch
                        // if prograde would be below minimum. Hard constraint only as final
                        // safety check.
                        
                        const altitudeFraction = Math.min(1.0, altitude / GUIDANCE_CONFIG.atmosphereLimit);
                        const minPitchForAltitude = 90 - altitudeFraction * altitudeFraction * 80; // Smooth quadratic curve
                        
                        // ============================================================
                        // PROGRADE FOLLOWING WITH CONSTRAINTS
                        // ============================================================
                        //
                        // CORE STRATEGY: Follow the velocity vector (prograde) to minimize
                        // angle of attack and drag losses. But apply constraints to prevent
                        // the gravity turn from running away.
                        //
                        // CONSTRAINT 1: Turn Rate Limiting
                        //   - Calculate natural gravity turn rate: ω = g * cos(γ) / v
                        //   - Monitor actual turn rate (how fast flight path angle is changing)
                        //   - If actual > natural + threshold, we're turning too fast → resist
                        //
                        // CONSTRAINT 2: Minimum Pitch for Altitude
                        //   - Soft constraint: gently push pitch up if below minimum
                        //   - Hard constraint: final safety check to never go below minimum
                        //
                        // This approach allows the rocket to follow its natural gravity turn
                        // while preventing it from pitching over too aggressively early in flight.
                        
                        // Start with prograde (minimizes angle of attack)
                        let basePitch = flightPathAngle;
                        
                        // Calculate natural gravity turn rate
                        // Formula: ω = g * cos(γ) / v  where γ = flight path angle
                        // This is how fast gravity WOULD rotate velocity if we thrust prograde
                        const g = getGravity(r);
                        const gamma = flightPathAngle * Math.PI / 180;
                        const naturalTurnRate = (g * Math.cos(gamma) / velocity) * 180 / Math.PI;  // deg/sec
                        
                        // Measure actual turn rate (how fast flight path angle is changing)
                        // Positive = turning downward (flight path angle decreasing)
                        const actualTurnRate = dt > 0 ? (guidanceState.lastFlightPathAngle - flightPathAngle) / dt : 0;
                        
                        // Store for next frame
                        guidanceState.lastFlightPathAngle = flightPathAngle;
                        
                        // CONSTRAINT 1: Turn rate limiting
                        // If we're turning faster than natural rate, something is wrong
                        // (maybe drag, maybe we commanded too low a pitch earlier)
                        // → Resist by pitching up
                        let correction = 0;
                        const turnRateExcess = actualTurnRate - naturalTurnRate;
                        
                        if (turnRateExcess > 0.5) {
                            // Turning faster than gravity alone — resist
                            correction = Math.min(5, turnRateExcess * 2);
                            debugInfo.reason = 'Turn rate excess — resisting';
                            debugInfo.turnRateExcess = turnRateExcess;
                        }
                        
                        // CONSTRAINT 2: Minimum pitch for altitude (soft constraint)
                        // If prograde would be below minimum, gently encourage higher pitch
                        // Use soft constraint (30% push) rather than hard to avoid fighting prograde
                        if (basePitch + correction < minPitchForAltitude) {
                            const deficit = minPitchForAltitude - (basePitch + correction);
                            correction += deficit * 0.3; // Gentle push, not hard constraint
                            debugInfo.reason = 'Altitude minimum pitch — gentle correction';
                        }
                        
                        // Final hard constraint: safety check to never go below minimum
                        commandedPitch = Math.max(minPitchForAltitude, basePitch + correction);
                        
                        debugInfo.basePitch = basePitch;
                        debugInfo.correction = correction;
                        debugInfo.minPitchForAltitude = minPitchForAltitude;
                        debugInfo.naturalTurnRate = naturalTurnRate;
                        debugInfo.actualTurnRate = actualTurnRate;
                    }
                }
            }
            
            // ------------------------------------------------------------------------
            // ABOVE ATMOSPHERE: Active guidance
            // ------------------------------------------------------------------------
            
            else {
                // PRIORITY 3: ANGLE — Correct orbit shape
                phase = 'vacuum-guidance';
                
                // Start with prograde as baseline
                let basePitch = flightPathAngle;
                let correction = 0;
                
                const apoapsisError = orbit.apoapsis - GUIDANCE_CONFIG.targetAltitude;
                const periapsisError = orbit.periapsis - GUIDANCE_CONFIG.targetAltitude;
                
                // Decision logic based on orbit state
                
                if (orbit.apoapsis < GUIDANCE_CONFIG.targetAltitude * 0.95) {
                    // Apoapsis too low — need to pitch UP to raise it
                    // The further below target, the more we pitch up
                    const deficit = GUIDANCE_CONFIG.targetAltitude - orbit.apoapsis;
                    correction = Math.min(GUIDANCE_CONFIG.maxPitchCorrection, deficit / 50000 * 10);
                    debugInfo.reason = 'Raising apoapsis — pitching up';
                }
                else if (orbit.apoapsis > GUIDANCE_CONFIG.targetAltitude * 1.05) {
                    // Apoapsis too high — need to pitch DOWN
                    const excess = orbit.apoapsis - GUIDANCE_CONFIG.targetAltitude;
                    correction = Math.max(-GUIDANCE_CONFIG.maxPitchCorrection, -excess / 50000 * 10);
                    debugInfo.reason = 'Lowering apoapsis — pitching down';
                }
                else {
                    // Apoapsis is close to target — focus on periapsis (circularization)
                    
                    if (orbit.periapsis < GUIDANCE_CONFIG.targetAltitude * 0.8) {
                        // Periapsis way too low — pitch DOWN to add horizontal velocity
                        const deficit = GUIDANCE_CONFIG.targetAltitude - orbit.periapsis;
                        correction = Math.max(-GUIDANCE_CONFIG.maxPitchCorrection, -deficit / 100000 * 10);
                        debugInfo.reason = 'Raising periapsis — pitching down for horizontal velocity';
                    }
                    else if (orbit.periapsis < GUIDANCE_CONFIG.targetAltitude * 0.95) {
                        // Periapsis slightly low — gentle pitch down
                        const deficit = GUIDANCE_CONFIG.targetAltitude - orbit.periapsis;
                        correction = Math.max(-5, -deficit / 50000 * 5);
                        debugInfo.reason = 'Fine-tuning periapsis — gentle pitch down';
                    }
                    else {
                        // Both apoapsis and periapsis are good — hold prograde
                        correction = 0;
                        debugInfo.reason = 'Orbit nominal — holding prograde';
                    }
                }
                
                commandedPitch = basePitch + correction;
                
                debugInfo.apoapsisError = apoapsisError;
                debugInfo.periapsisError = periapsisError;
                debugInfo.correction = correction;
                debugInfo.eccentricity = orbit.eccentricity;
                
                // --------------------------------------------------------------------
                // PRIORITY 4: VELOCITY — Throttle control near end of burn
                // --------------------------------------------------------------------
                
                // Only throttle down if:
                // 1. We're in vacuum (past atmosphere)
                // 2. We have more delta-v than we need
                // 3. Our orbit is close to target (don't throttle down if we're way off)
                
                const orbitIsClose = Math.abs(apoapsisError) < 50000 && orbit.periapsis > 0;
                
                if (orbitIsClose && remainingDeltaV > velocityDeficit * GUIDANCE_CONFIG.throttleDownMargin) {
                    // We have excess delta-v — throttle down to hit target precisely
                    
                    // Calculate ideal throttle to use remaining fuel over remaining velocity needed
                    const idealThrottle = velocityDeficit / remainingDeltaV;
                    
                    commandedThrottle = Math.max(GUIDANCE_CONFIG.minThrottle, idealThrottle);
                    
                    debugInfo.throttleReason = 'Throttling down for precision';
                    debugInfo.velocityDeficit = velocityDeficit;
                    debugInfo.remainingDeltaV = remainingDeltaV;
                }
                else {
                    commandedThrottle = 1.0;
                    debugInfo.throttleReason = 'Full throttle';
                }
            }
            
            // ========================================================================
            // STEP 5: APPLY CONSTRAINTS
            // ========================================================================
            
            // Clamp pitch to valid range
            commandedPitch = Math.max(-5, Math.min(90, commandedPitch));
            
            // Rate limiting — rocket can only rotate so fast
            if (dt > 0) {
                const maxChange = GUIDANCE_CONFIG.maxPitchRate * dt;
                const desiredChange = commandedPitch - guidanceState.lastCommandedPitch;
                
                if (Math.abs(desiredChange) > maxChange) {
                    commandedPitch = guidanceState.lastCommandedPitch + 
                                    Math.sign(desiredChange) * maxChange;
                }
            }
            
            // Store for next frame
            guidanceState.lastCommandedPitch = commandedPitch;
            guidanceState.phase = phase;
            guidanceState.throttle = commandedThrottle;
            
            // ========================================================================
            // STEP 6: CONVERT TO THRUST VECTOR
            // ========================================================================
            
            const pitchRad = commandedPitch * Math.PI / 180;
            const thrustDir = {
                x: Math.cos(pitchRad) * localEast.x + Math.sin(pitchRad) * localUp.x,
                y: Math.cos(pitchRad) * localEast.y + Math.sin(pitchRad) * localUp.y
            };
            
            // Normalize
            const mag = Math.sqrt(thrustDir.x * thrustDir.x + thrustDir.y * thrustDir.y);
            if (mag > 0) {
                thrustDir.x /= mag;
                thrustDir.y /= mag;
            }
            
            return {
                pitch: commandedPitch,
                thrustDir: thrustDir,
                throttle: commandedThrottle,
                phase: phase,
                debug: debugInfo,
                orbit: orbit,
                velocityDeficit: velocityDeficit,
                remainingDeltaV: remainingDeltaV,
            };
        }
        
        let state = {
            running: false,
            time: 0,
            timeWarp: 1,
            x: 0,
            y: EARTH_RADIUS,
            vx: 0,
            vy: 0,
            currentStage: 0,
            propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
            fairingJettisoned: false,
            maxQ: 0,
            events: [],
            apoapsis: 0,
            periapsis: 0,
            engineOn: false,
            trail: [],
            manualZoom: 1.0,
            autoZoom: true,
            cameraMode: 'rocket', // 'rocket' or 'earth'
            burnMode: null, // null, 'prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'
            burnStartTime: null // Time when current burn started
        };
        
        const LAUNCH_LATITUDE = 28.5 * Math.PI / 180;
        
        function initState() {
            // Initialize rocket at pad position
            const x0 = 0;
            const y0 = EARTH_RADIUS;
            
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Rocket should start with this velocity so airspeed is ~0
            // Earth rotates counterclockwise (eastward)
            const atmVx0 = EARTH_ROTATION * y0;  // perpendicular to position vector (eastward)
            const atmVy0 = -EARTH_ROTATION * x0;
            
            state = {
                running: false,
                time: 0,
                timeWarp: 1,
                x: x0,
                y: y0,
                vx: atmVx0,  // Match atmospheric velocity so airspeed is ~0
                vy: atmVy0,
                currentStage: 0,
                propellantRemaining: [ROCKET_CONFIG.stages[0].propellantMass, ROCKET_CONFIG.stages[1].propellantMass],
                fairingJettisoned: false,
                maxQ: 0,
                events: [],
                apoapsis: 0,
                periapsis: 0,
                engineOn: false,
                trail: [],
                manualZoom: 1.0,
                autoZoom: true,
                cameraMode: 'rocket', // 'rocket' or 'earth'
                burnMode: null, // null, 'prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'
                burnStartTime: null, // Time when current burn started
                guidancePhase: 'pre-launch',
                guidancePitch: 90.0
            };
            
            document.getElementById('event-list').innerHTML = '';
            resetGuidance();
        }
        
        function getTotalMass() {
            let mass = ROCKET_CONFIG.payload;
            if (!state.fairingJettisoned) mass += ROCKET_CONFIG.fairingMass;
            for (let i = state.currentStage; i < ROCKET_CONFIG.stages.length; i++) {
                mass += ROCKET_CONFIG.stages[i].dryMass + state.propellantRemaining[i];
            }
            return mass;
        }
        
        function getAltitude() {
            return Math.sqrt(state.x * state.x + state.y * state.y) - EARTH_RADIUS;
        }
        
        function getAtmosphericDensity(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_DENSITY * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getAtmosphericPressure(altitude) {
            if (altitude > 150000) return 0;
            return SEA_LEVEL_PRESSURE * Math.exp(-Math.max(0, altitude) / ATM_SCALE_HEIGHT);
        }
        
        function getGravity(r) {
            return G * EARTH_MASS / (r * r);
        }
        
        function getPitch(time) {
            // Use guidance system pitch (pitch from horizontal: 0° = east, 90° = up)
            // Convert to pitch from vertical for backward compatibility (90° = up, 0° = horizontal)
            if (state.guidancePitch !== undefined) {
                return state.guidancePitch; // Guidance system already uses correct convention
            }
            // Fallback if guidance hasn't run yet
            return 90.0;
        }
        
        function getCurrentThrust(altitude, throttle = 1.0) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            const baseThrust = stage.thrust * pressureRatio + stage.thrustVac * (1 - pressureRatio);
            return baseThrust * throttle;
        }
        
        function getMassFlowRate(altitude, throttle = 1.0) {
            if (!state.engineOn || state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            if (state.propellantRemaining[state.currentStage] <= 0) return 0;
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const pressureRatio = getAtmosphericPressure(altitude) / SEA_LEVEL_PRESSURE;
            const isp = stage.isp * pressureRatio + stage.ispVac * (1 - pressureRatio);
            return getCurrentThrust(altitude, throttle) / (isp * 9.81);
        }
        
        function getAirspeed() {
            // Atmospheric velocity at rocket's position (rotating with Earth)
            // Earth rotates counterclockwise (eastward), so velocity is perpendicular to position vector
            const atmVx = EARTH_ROTATION * state.y;  // perpendicular to position vector (eastward)
            const atmVy = -EARTH_ROTATION * state.x;
            
            // Airspeed (velocity relative to atmosphere)
            const airVx = state.vx - atmVx;
            const airVy = state.vy - atmVy;
            const airspeed = Math.sqrt(airVx * airVx + airVy * airVy);
            
            return { airspeed, airVx, airVy };
        }
        
        function getDrag(altitude, airspeed) {
            if (state.currentStage >= ROCKET_CONFIG.stages.length) return 0;
            const density = getAtmosphericDensity(altitude);
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            const area = Math.PI * (stage.diameter / 2) ** 2;
            return 0.5 * density * airspeed * airspeed * stage.dragCoeff * area;
        }
        
        function calculateOrbitalElements() {
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / r);
            const a = -mu / (2 * energy);
            const h = state.x * state.vy - state.y * state.vx;
            const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
            
            if (a > 0 && e < 1) {
                state.apoapsis = a * (1 + e) - EARTH_RADIUS;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
            } else {
                state.apoapsis = Infinity;
                state.periapsis = a * (1 - e) - EARTH_RADIUS;
            }
        }
        
        function addEvent(text) {
            const timeStr = formatTime(state.time);
            state.events.push({ time: timeStr, text });
            const eventList = document.getElementById('event-list');
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event';
            eventDiv.innerHTML = `<span class="event-time">T+${timeStr}</span> ${text}`;
            eventList.insertBefore(eventDiv, eventList.firstChild);
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }
        
        function update(dt) {
            if (!state.running) return;
            
            dt *= state.timeWarp;
            // Cap maximum timestep to prevent numerical instability at very high time warps
            // This ensures we don't try to integrate too far in one step
            const maxDt = 1.0; // Maximum 1 second per frame
            if (dt > maxDt) {
                dt = maxDt;
            }
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            if (r < EARTH_RADIUS && state.time > 1) {
                state.running = false;
                addEvent("MISSION FAILURE - Ground impact");
                return;
            }
            
            const mass = getTotalMass();
            
            // Gravity pointing toward Earth center
            const gravity = getGravity(r);
            const gx = -gravity * state.x / r;
            const gy = -gravity * state.y / r;
            
            // Local reference frame
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            
            // Calculate orbital directions if in orbit
            // Only allow burns after pitch program is complete (engine off, in orbit)
            let thrustDir;
            const pitchProgramComplete = state.time > 600 || (!state.engineOn && altitude > 150000);
            if (state.burnMode && pitchProgramComplete && altitude > 150000) {
                // Orbital burn mode - calculate direction based on burn type
                const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                const prograde = velocity > 0 ? { x: state.vx / velocity, y: state.vy / velocity } : { x: 0, y: 0 };
                const radial = localUp;
                const h = state.x * state.vy - state.y * state.vx; // Angular momentum
                const normal = h > 0 ? { x: -localUp.y, y: localUp.x } : { x: localUp.y, y: -localUp.x }; // Perpendicular to orbit plane
                
                switch (state.burnMode) {
                    case 'prograde':
                        thrustDir = prograde;
                        break;
                    case 'retrograde':
                        thrustDir = { x: -prograde.x, y: -prograde.y };
                        break;
                    case 'normal':
                        thrustDir = normal;
                        break;
                    case 'anti-normal':
                        thrustDir = { x: -normal.x, y: -normal.y };
                        break;
                    case 'radial':
                        thrustDir = radial;
                        break;
                    case 'anti-radial':
                        thrustDir = { x: -radial.x, y: -radial.y };
                        break;
                    default:
                        thrustDir = prograde;
                }
            } else {
                // Closed-loop guidance system
                const guidance = computeGuidance(state, dt);
                thrustDir = guidance.thrustDir;
                // Store guidance phase for telemetry
                state.guidancePhase = guidance.phase;
                state.guidancePitch = guidance.pitch;
                state.guidanceThrottle = guidance.throttle;
            }
            
            // Thrust - enable engine if in burn mode, pitch program complete, and have propellant
            if (state.burnMode && pitchProgramComplete && !state.engineOn && altitude > 150000 && 
                state.currentStage < ROCKET_CONFIG.stages.length && 
                state.propellantRemaining[state.currentStage] > 0) {
                state.engineOn = true;
            }
            
            // Get throttle from guidance state (or default to 1.0 for burn modes)
            const throttle = state.guidanceThrottle !== undefined ? state.guidanceThrottle : 1.0;
            const thrust = getCurrentThrust(altitude, throttle);
            const thrustAccel = thrust / mass;
            const tax = thrustAccel * thrustDir.x;
            const tay = thrustAccel * thrustDir.y;
            
            // Drag opposing airspeed (velocity relative to atmosphere)
            const { airspeed, airVx, airVy } = getAirspeed();
            const drag = getDrag(altitude, airspeed);
            const dragAccel = airspeed > 0 ? drag / mass : 0;
            const dax = airspeed > 0 ? -dragAccel * airVx / airspeed : 0;
            const day = airspeed > 0 ? -dragAccel * airVy / airspeed : 0;
            
            // Use adaptive sub-stepping for large timesteps to reduce integration errors
            // This is especially important in orbit where energy should be conserved
            // Use smaller steps in orbit to maintain accuracy
            const inOrbit = altitude > 150000 && !state.engineOn;
            const maxStepSize = inOrbit ? 0.01 : 0.05; // Smaller steps in orbit (10ms vs 50ms)
            const steps = Math.max(1, Math.ceil(dt / maxStepSize));
            const stepDt = dt / steps;
            
            // Limit maximum steps to prevent performance issues
            const maxSteps = 1000;
            const actualSteps = Math.min(steps, maxSteps);
            const actualStepDt = dt / actualSteps;
            
            for (let step = 0; step < actualSteps; step++) {
                // Recalculate forces at current position for each sub-step
                const rStep = Math.sqrt(state.x * state.x + state.y * state.y);
                const altitudeStep = rStep - EARTH_RADIUS;
                const velocityStep = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                
                // Gravity at current position
                const gravityStep = getGravity(rStep);
                const gxStep = -gravityStep * state.x / rStep;
                const gyStep = -gravityStep * state.y / rStep;
                
                // Thrust (recalculate if needed, but typically constant during step)
                const thrustStep = getCurrentThrust(altitudeStep, throttle);
                const thrustAccelStep = thrustStep / mass;
                const taxStep = thrustAccelStep * thrustDir.x;
                const tayStep = thrustAccelStep * thrustDir.y;
                
                // Drag at current position (using airspeed)
                // Earth rotates counterclockwise (eastward)
                const atmVxStep = EARTH_ROTATION * state.y;  // eastward
                const atmVyStep = -EARTH_ROTATION * state.x;
                const airVxStep = state.vx - atmVxStep;
                const airVyStep = state.vy - atmVyStep;
                const airspeedStep = Math.sqrt(airVxStep * airVxStep + airVyStep * airVyStep);
                const dragStep = getDrag(altitudeStep, airspeedStep);
                const dragAccelStep = airspeedStep > 0 ? dragStep / mass : 0;
                const daxStep = airspeedStep > 0 ? -dragAccelStep * airVxStep / airspeedStep : 0;
                const dayStep = airspeedStep > 0 ? -dragAccelStep * airVyStep / airspeedStep : 0;
                
                // Total acceleration
                const axStep = gxStep + taxStep + daxStep;
                const ayStep = gyStep + tayStep + dayStep;
                
                // Symplectic Euler integrator (conserves energy better than standard Euler)
                state.vx += axStep * actualStepDt;
                state.vy += ayStep * actualStepDt;
                state.x += state.vx * actualStepDt;
                state.y += state.vy * actualStepDt;
            }
            
            // Propellant consumption
            if (state.engineOn && state.currentStage < ROCKET_CONFIG.stages.length) {
                state.propellantRemaining[state.currentStage] -= getMassFlowRate(altitude, throttle) * dt;
                
                if (state.propellantRemaining[state.currentStage] <= 0) {
                    state.propellantRemaining[state.currentStage] = 0;
                    if (state.currentStage === 0) {
                        addEvent("MECO");
                        state.currentStage = 1;
                        addEvent("Stage separation");
                        addEvent("SES-1");
                    } else {
                        addEvent("SECO");
                        state.engineOn = false;
                        // Turn off burn mode when propellant runs out
                        if (state.burnMode) {
                            const burnNames = {
                                'prograde': 'PROGRADE',
                                'retrograde': 'RETROGRADE',
                                'normal': 'NORMAL',
                                'anti-normal': 'ANTI-NORMAL',
                                'radial': 'RADIAL',
                                'anti-radial': 'ANTI-RADIAL'
                            };
                            const duration = state.burnStartTime ? (state.time - state.burnStartTime).toFixed(1) : '0.0';
                            addEvent(`${burnNames[state.burnMode]} burn ended - out of propellant (${duration}s)`);
                            state.burnMode = null;
                            state.burnStartTime = null;
                        }
                    }
                }
            }
            
            // Turn off burn mode if engine turns off for any reason
            if (state.burnMode && !state.engineOn && state.burnStartTime !== null) {
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                const duration = (state.time - state.burnStartTime).toFixed(1);
                addEvent(`${burnNames[state.burnMode]} burn ended (${duration}s)`);
                state.burnMode = null;
                state.burnStartTime = null;
            }
            
            // Update burn duration
            if (state.burnMode && state.burnStartTime !== null) {
                // Burn duration is tracked, will be displayed in telemetry
            } else if (state.burnMode && state.burnStartTime === null) {
                // Just started burning
                state.burnStartTime = state.time;
            }
            
            if (!state.fairingJettisoned && altitude > ROCKET_CONFIG.fairingJettisonAlt) {
                state.fairingJettisoned = true;
                addEvent("Fairing jettison");
            }
            
            // Dynamic pressure using airspeed (velocity relative to atmosphere)
            const { airspeed: airspeedForQ } = getAirspeed();
            const dynPress = 0.5 * getAtmosphericDensity(altitude) * airspeedForQ * airspeedForQ;
            if (dynPress > state.maxQ) state.maxQ = dynPress;
            
            calculateOrbitalElements();
            
            // Add to trail more frequently and keep more points
            if (state.time % 0.1 < dt * state.timeWarp) {
                state.trail.push({ x: state.x, y: state.y });
                // Keep more trail points (10000 instead of 3000) so it doesn't disappear
                if (state.trail.length > 10000) state.trail.shift();
            }
            
            // Gravity turn events
            if (state.time >= 10.0 && !state.events.some(e => e.text.includes("Gravity turn kick"))) {
                addEvent("Gravity turn kick");
            }
            if (state.time >= 13.0 && !state.events.some(e => e.text.includes("Gravity turn active"))) {
                addEvent("Gravity turn active - thrusting prograde");
            }
            
            if (altitude >= KARMAN_LINE && !state.events.some(e => e.text.includes("Kármán"))) {
                addEvent("Kármán line - SPACE!");
            }
            
            state.time += dt;
            updateTelemetry();
        }
        
        function getNextEvent() {
            const altitude = getAltitude();
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const events = [];
            
            // Pitch program start (first pitch change at 10s)
            if (state.time < 10) {
                events.push({ time: 10 - state.time, name: 'Pitch program start' });
            }
            
            // Kármán line (100km)
            if (altitude < KARMAN_LINE && !state.events.some(e => e.text.includes("Kármán"))) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToKarman = (KARMAN_LINE - altitude) / vVert;
                    if (timeToKarman > 0 && timeToKarman < 10000) {
                        events.push({ time: timeToKarman, name: 'Kármán line' });
                    }
                }
            }
            
            // Fairing jettison (110km)
            if (!state.fairingJettisoned && altitude < ROCKET_CONFIG.fairingJettisonAlt) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToFairing = (ROCKET_CONFIG.fairingJettisonAlt - altitude) / vVert;
                    if (timeToFairing > 0 && timeToFairing < 10000) {
                        events.push({ time: timeToFairing, name: 'Fairing jettison' });
                    }
                }
            }
            
            // Stage separation (when stage 0 propellant runs out)
            if (state.currentStage === 0 && state.propellantRemaining[0] > 0 && state.engineOn) {
                const throttle = state.guidanceThrottle !== undefined ? state.guidanceThrottle : 1.0;
                const massFlowRate = getMassFlowRate(altitude, throttle);
                if (massFlowRate > 0) {
                    const timeToSeparation = state.propellantRemaining[0] / massFlowRate;
                    if (timeToSeparation > 0 && timeToSeparation < 10000) {
                        events.push({ time: timeToSeparation, name: 'Stage separation' });
                    }
                }
            }
            
            // Orbit (150km altitude and engine off) - only show if not yet in orbit
            const inOrbit = altitude >= 150000 && !state.engineOn;
            if (!inOrbit && altitude < 150000) {
                const vVert = (state.vx * state.x + state.vy * state.y) / Math.sqrt(state.x * state.x + state.y * state.y);
                if (vVert > 0) {
                    const timeToOrbit = (150000 - altitude) / vVert;
                    if (timeToOrbit > 0 && timeToOrbit < 10000) {
                        // Also need engine to be off, so add time for propellant burn if needed
                        let totalTime = timeToOrbit;
                        if (state.engineOn && state.currentStage < ROCKET_CONFIG.stages.length) {
                            const throttle = state.guidanceThrottle !== undefined ? state.guidanceThrottle : 1.0;
                            const massFlowRate = getMassFlowRate(altitude, throttle);
                            if (massFlowRate > 0 && state.propellantRemaining[state.currentStage] > 0) {
                                const timeToBurnout = state.propellantRemaining[state.currentStage] / massFlowRate;
                                totalTime = Math.max(timeToOrbit, timeToBurnout);
                            }
                        }
                        events.push({ time: totalTime, name: 'Orbit' });
                    }
                }
            }
            
            // SECO (when stage 1 propellant runs out)
            if (state.currentStage === 1 && state.propellantRemaining[1] > 0 && state.engineOn) {
                const throttle = state.guidanceThrottle !== undefined ? state.guidanceThrottle : 1.0;
                const massFlowRate = getMassFlowRate(altitude, throttle);
                if (massFlowRate > 0) {
                    const timeToSECO = state.propellantRemaining[1] / massFlowRate;
                    if (timeToSECO > 0 && timeToSECO < 10000) {
                        events.push({ time: timeToSECO, name: 'SECO' });
                    }
                }
            }
            
            // Return the event with the shortest time
            if (events.length > 0) {
                events.sort((a, b) => a.time - b.time);
                return events[0];
            }
            return null;
        }
        
        function formatTMinus(seconds) {
            if (seconds <= 0) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateTelemetry() {
            const altitude = getAltitude();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            
            const localUp = { x: state.x / r, y: state.y / r };
            const vVert = state.vx * localUp.x + state.vy * localUp.y;
            const vHoriz = Math.sqrt(Math.max(0, velocity * velocity - vVert * vVert));
            const downrange = Math.atan2(state.x, state.y) * EARTH_RADIUS;
            
            document.getElementById('time').textContent = formatTime(state.time);
            
            // Update T-minus countdown (central display)
            const nextEvent = getNextEvent();
            const tminusDisplay = document.getElementById('tminus-display');
            if (nextEvent && state.running && state.time > 0) {
                tminusDisplay.style.display = 'block';
                document.getElementById('tminus-time').textContent = 'T- ' + formatTMinus(nextEvent.time);
                document.getElementById('tminus-event-name').textContent = nextEvent.name.toUpperCase();
            } else {
                tminusDisplay.style.display = 'none';
            }
            document.getElementById('stage').textContent = state.currentStage + 1;
            document.getElementById('altitude').textContent = (altitude / 1000).toFixed(2) + ' km';
            document.getElementById('downrange').textContent = (downrange / 1000).toFixed(1) + ' km';
            document.getElementById('velocity').textContent = velocity.toFixed(0) + ' m/s';
            document.getElementById('vvel').textContent = vVert.toFixed(0) + ' m/s';
            document.getElementById('hvel').textContent = vHoriz.toFixed(0) + ' m/s';
            
            const throttle = state.guidanceThrottle !== undefined ? state.guidanceThrottle : 1.0;
            const thrust = getCurrentThrust(altitude, throttle);
            const mass = getTotalMass();
            document.getElementById('accel').textContent = (thrust / mass / 9.81).toFixed(2) + ' G';
            document.getElementById('maxq').textContent = (state.maxQ / 1000).toFixed(2) + ' kPa';
            const { airspeed: airspeedForDisplay } = getAirspeed();
            document.getElementById('dynpress').textContent = (0.5 * getAtmosphericDensity(altitude) * airspeedForDisplay * airspeedForDisplay / 1000).toFixed(2) + ' kPa';
            document.getElementById('mass').textContent = mass.toFixed(0) + ' kg';
            
            const stage = ROCKET_CONFIG.stages[state.currentStage];
            if (stage) {
                document.getElementById('propellant').textContent = (state.propellantRemaining[state.currentStage] / stage.propellantMass * 100).toFixed(1) + '%';
            }
            document.getElementById('thrust').textContent = (thrust / 1000).toFixed(0) + ' kN';
            
            const pitch = getPitch(state.time);
            document.getElementById('pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('target-pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('current-pitch').textContent = pitch.toFixed(1) + '°';
            document.getElementById('pitch-bar').style.width = (pitch / 90 * 100) + '%';
            
            document.getElementById('apoapsis').textContent = state.apoapsis === Infinity ? 'ESCAPE' : (state.apoapsis / 1000).toFixed(1) + ' km';
            document.getElementById('periapsis').textContent = (state.periapsis / 1000).toFixed(1) + ' km';
            
            // Show/hide burn controls when in orbit and pitch program is complete
            const pitchProgramComplete = state.time > 600 || (!state.engineOn && altitude > 150000);
            const inOrbit = altitude > 150000 && state.currentStage < ROCKET_CONFIG.stages.length && pitchProgramComplete;
            const burnControls = document.getElementById('burn-controls');
            if (inOrbit) {
                burnControls.style.display = 'block';
            } else {
                burnControls.style.display = 'none';
                // Clear burn mode if not in orbit or pitch program still running
                if (state.burnMode) {
                    state.burnMode = null;
                    state.burnStartTime = null;
                }
            }
            
            // Update active burn button and burn status
            const burnButtons = ['prograde', 'retrograde', 'normal', 'anti-normal', 'radial', 'anti-radial'];
            burnButtons.forEach(mode => {
                const btn = document.getElementById(`burn-${mode}-btn`);
                if (btn) {
                    if (state.burnMode === mode) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
            
            // Update burn status display
            const burnStatus = document.getElementById('burn-status');
            if (state.burnMode && state.burnStartTime !== null) {
                const burnDuration = state.time - state.burnStartTime;
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                burnStatus.innerHTML = `
                    <div style="color: #0ff; font-weight: bold;">BURNING: ${burnNames[state.burnMode]}</div>
                    <div style="color: #0f0;">Duration: ${burnDuration.toFixed(1)}s</div>
                `;
            } else {
                burnStatus.innerHTML = '<div>Hold button to burn</div>';
            }
        }
        
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const altitude = getAltitude();
            
            // ZOOM: Start at 2 m/px (very close), smoothly zoom out as altitude increases
            const minMPP = 2;
            // Allow zooming out to see full orbits (up to 20x Earth radius when following rocket)
            // No bounds when centered on Earth
            const maxMPP = state.cameraMode === 'earth' ? Infinity : (EARTH_RADIUS * 20 / Math.min(canvas.width, canvas.height));
            
            let autoMetersPerPixel;
            if (state.cameraMode === 'earth') {
                // When centered on Earth, use a default zoom that shows Earth nicely
                // Default to showing about 2x Earth radius
                const defaultEarthZoom = EARTH_RADIUS * 2.5 / Math.min(canvas.width, canvas.height);
                autoMetersPerPixel = defaultEarthZoom;
            } else if (altitude < 500) {
                autoMetersPerPixel = minMPP;
            } else {
                // Smooth logarithmic zoom - extend range for orbital viewing
                const zoomProgress = Math.min(1, Math.log10(altitude / 500) / 6);
                autoMetersPerPixel = minMPP * Math.pow(maxMPP / minMPP, zoomProgress);
            }
            
            // Apply manual zoom on top of auto zoom
            // In Earth mode, always use manual zoom (ignore autoZoom setting)
            const metersPerPixel = (state.cameraMode === 'earth' || !state.autoZoom) 
                ? autoMetersPerPixel / state.manualZoom 
                : autoMetersPerPixel / state.manualZoom;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 200; i++) {
                const sx = (Math.sin(i * 567.89 + 1000) * 0.5 + 0.5) * canvas.width;
                const sy = (Math.cos(i * 123.45 + 500) * 0.5 + 0.5) * canvas.height;
                ctx.fillRect(sx, sy, Math.random() > 0.85 ? 2 : 1, 1);
            }
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(1 / metersPerPixel, -1 / metersPerPixel);
             // Rotate 90 degrees counterclockwise
            
            // Camera: either follow rocket or center on Earth
            if (state.cameraMode === 'earth') {
                ctx.translate(0, 0); // Center on Earth (0, 0)
            } else {
                ctx.translate(-state.x, -state.y); // Follow rocket
            }
            
            // Earth
            ctx.beginPath();
            ctx.arc(0, 0, EARTH_RADIUS, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(-EARTH_RADIUS * 0.3, EARTH_RADIUS * 0.3, 0, 0, 0, EARTH_RADIUS);
            grad.addColorStop(0, '#3a7d32');
            grad.addColorStop(0.6, '#1a5a1a');
            grad.addColorStop(1, '#0a3a0a');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#2a8a2a';
            ctx.lineWidth = metersPerPixel * 2;
            ctx.stroke();
            
            // Ground detail when close
            if (metersPerPixel < 20) {
                ctx.fillStyle = '#555';
                ctx.fillRect(-30, EARTH_RADIUS - 1, 60, 2);
                ctx.fillStyle = '#777';
                ctx.fillRect(-25, EARTH_RADIUS, 4, 60);
            }
            
            // Atmosphere layers (when zoomed out)
            if (metersPerPixel > 50) {
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, EARTH_RADIUS + (i + 1) * 25000, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(100, 150, 255, ${0.1 - i * 0.02})`;
                    ctx.lineWidth = 20000;
                    ctx.stroke();
                }
            }
            
            // Karman line
            if (metersPerPixel > 200) {
                ctx.beginPath();
                ctx.arc(0, 0, EARTH_RADIUS + KARMAN_LINE, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.lineWidth = 1500;
                ctx.setLineDash([15000, 15000]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Trail - make it more visible and persistent
            if (state.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(state.trail[0].x, state.trail[0].y);
                for (let i = 1; i < state.trail.length; i++) {
                    ctx.lineTo(state.trail[i].x, state.trail[i].y);
                }
                ctx.strokeStyle = 'rgba(255, 120, 0, 0.8)';
                // Make trail thicker and more visible, especially when zoomed out
                ctx.lineWidth = Math.max(metersPerPixel * 2, 2);
                ctx.stroke();
            }
            
            // Rocket - ACTUAL SIZE 70m x 3.7m
            const rocketLen = 70;
            const rocketWid = 3.7;
            
            ctx.save();
            const r = Math.sqrt(state.x * state.x + state.y * state.y);
            const localUp = { x: state.x / r, y: state.y / r };
            const localEast = { x: localUp.y, y: -localUp.x };
            // Move rocket up by half its length so it sits on top of the pad
            ctx.translate(state.x + localUp.x * rocketLen * 0.5, state.y + localUp.y * rocketLen * 0.5);
            
            // Calculate thrust direction vector (same logic as physics update)
            let thrustDir;
            const pitchProgramComplete = state.time > 600 || (!state.engineOn && getAltitude() > 150000);
            if (state.burnMode && pitchProgramComplete && getAltitude() > 150000) {
                // Orbital burn mode
                const velocity = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                thrustDir = velocity > 0 ? { x: state.vx / velocity, y: state.vy / velocity } : { x: localUp.x, y: localUp.y };
            } else {
                // Closed-loop guidance system (same as physics update)
                const guidance = computeGuidance(state, 0.016); // Use typical frame time for rendering
                thrustDir = guidance.thrustDir;
            }
            
            // Rocket angle: point rocket nose (at negative Y in drawing coords) in thrust direction
            // Since canvas Y is flipped, negative Y in drawing = positive Y on screen (up)
            // Add π/2 offset to correct for 90° counter-clockwise misalignment
            const rocketAngle = Math.atan2(thrustDir.y, thrustDir.x) - Math.PI / 2;
            ctx.rotate(rocketAngle);
            
            // Make rocket visible even when zoomed out
            const minPixelSize = 12;
            const scale = Math.max(1, minPixelSize * metersPerPixel / rocketLen);
            const drawLen = rocketLen * scale;
            const drawWid = rocketWid * scale;
            
            // Body
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(-drawWid/2, -drawLen * 0.4, drawWid, drawLen * 0.8);
            
            // Nose (at positive Y to point in thrust direction)
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, drawLen * 0.4);
            ctx.lineTo(0, drawLen * 0.55);
            ctx.lineTo(drawWid/2, drawLen * 0.4);
            ctx.fillStyle = '#d33';
            ctx.fill();
            
            // Fins (at negative Y, engine end)
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.moveTo(-drawWid/2, -drawLen * 0.35);
            ctx.lineTo(-drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(-drawWid/2, -drawLen * 0.2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(drawWid/2, -drawLen * 0.35);
            ctx.lineTo(drawWid * 0.9, -drawLen * 0.45);
            ctx.lineTo(drawWid/2, -drawLen * 0.2);
            ctx.fill();
            
            // Flame (at negative Y, engine end)
            if (state.engineOn && state.propellantRemaining[state.currentStage] > 0) {
                const flameLen = drawLen * (0.5 + Math.random() * 0.25);
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.2, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, 0, -drawLen * 0.4 - flameLen);
                ctx.quadraticCurveTo(drawWid * 0.35, -drawLen * 0.4 - flameLen * 0.5, drawWid * 0.2, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${80 + Math.random() * 60}, 0)`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-drawWid * 0.1, -drawLen * 0.4);
                ctx.quadraticCurveTo(-drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, 0, -drawLen * 0.4 - flameLen * 0.6);
                ctx.quadraticCurveTo(drawWid * 0.15, -drawLen * 0.4 - flameLen * 0.35, drawWid * 0.1, -drawLen * 0.4);
                ctx.fillStyle = `rgb(255, ${200 + Math.random() * 55}, ${100 + Math.random() * 80})`;
                ctx.fill();
            }
            
            ctx.restore(); // Restore rocket rotation
            
            // Draw thrust vector arrow
            if (state.engineOn && state.propellantRemaining[state.currentStage] > 0) {
                const arrowLength = 100; // meters
                const arrowHeadSize = 12; // meters
                
                ctx.save();
                const rArrow = Math.sqrt(state.x * state.x + state.y * state.y);
                const localUpArrow = { x: state.x / rArrow, y: state.y / rArrow };
                // Position arrow at same location as rocket (offset by half rocket length)
                ctx.translate(state.x + localUpArrow.x * rocketLen * 0.5, state.y + localUpArrow.y * rocketLen * 0.5);
                
                // Draw arrow line in thrust direction
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(thrustDir.x * arrowLength, thrustDir.y * arrowLength);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = metersPerPixel * 3;
                ctx.stroke();
                
                // Draw arrowhead (pointing forward in thrust direction)
                const arrowX = thrustDir.x * arrowLength;
                const arrowY = thrustDir.y * arrowLength;
                const arrowAngle = Math.atan2(thrustDir.y, thrustDir.x);
                
                // Arrowhead: tip is at the end of the arrow, base is slightly back
                const tipX = arrowX;
                const tipY = arrowY;
                const baseOffset = arrowHeadSize * 0.8;
                const baseX = arrowX - baseOffset * Math.cos(arrowAngle);
                const baseY = arrowY - baseOffset * Math.sin(arrowAngle);
                const wingOffset = arrowHeadSize * 0.5;
                
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(
                    baseX + wingOffset * Math.cos(arrowAngle + Math.PI / 2),
                    baseY + wingOffset * Math.sin(arrowAngle + Math.PI / 2)
                );
                ctx.lineTo(
                    baseX + wingOffset * Math.cos(arrowAngle - Math.PI / 2),
                    baseY + wingOffset * Math.sin(arrowAngle - Math.PI / 2)
                );
                ctx.closePath();
                ctx.fillStyle = '#0ff';
                ctx.fill();
                
                ctx.restore();
            }
            
            // Orbit prediction - draw before restoring coordinate transform
            // Always show when in orbit (elliptical or circular)
            const v = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
            const mu = G * EARTH_MASS;
            const energy = (v * v / 2) - (mu / r);
            if (altitude > 10000 && energy < 0) {
                const a = -mu / (2 * energy);
                const h = state.x * state.vy - state.y * state.vx;
                const e = Math.sqrt(Math.max(0, 1 + (2 * energy * h * h) / (mu * mu)));
                if (e < 1 && a > 0 && a < EARTH_RADIUS * 50 && e > 0.001) {
                    // Calculate orbit orientation using eccentricity vector (more stable)
                    const v2 = v * v;
                    const rVec = { x: state.x, y: state.y };
                    const vVec = { x: state.vx, y: state.vy };
                    
                    // Eccentricity vector points toward periapsis
                    const rDotV = rVec.x * vVec.x + rVec.y * vVec.y;
                    const eVec = {
                        x: ((v2 - mu / r) * rVec.x - rDotV * vVec.x) / mu,
                        y: ((v2 - mu / r) * rVec.y - rDotV * vVec.y) / mu
                    };
                    
                    // Argument of periapsis (angle of periapsis from reference direction)
                    const periapsisAngle = Math.atan2(eVec.y, eVec.x);
                    
                    // Current true anomaly - verify it matches current position
                    const rDotE = rVec.x * eVec.x + rVec.y * eVec.y;
                    const cosNu = Math.max(-1, Math.min(1, rDotE / (r * e)));
                    const rDotVNorm = rDotV / Math.sqrt(mu * a);
                    const sinNu = Math.max(-1, Math.min(1, rDotVNorm / e));
                    const nu = Math.atan2(sinNu, cosNu);
                    
                    // Verify: current position should be at periapsisAngle + nu
                    // So orbit is drawn with periapsis at periapsisAngle
                    const theta0 = periapsisAngle;
                    
                    ctx.beginPath();
                    let firstPoint = true;
                    let lastValidPoint = null;
                    for (let ang = 0; ang <= Math.PI * 2 + 0.05; ang += 0.01) {
                        const rOrb = a * (1 - e * e) / (1 + e * Math.cos(ang));
                        if (rOrb > EARTH_RADIUS && rOrb < EARTH_RADIUS * 50 && isFinite(rOrb)) {
                            const xO = rOrb * Math.cos(ang + theta0);
                            const yO = rOrb * Math.sin(ang + theta0);
                            if (isFinite(xO) && isFinite(yO)) {
                                if (firstPoint) {
                                    ctx.moveTo(xO, yO);
                                    firstPoint = false;
                                    lastValidPoint = { x: xO, y: yO };
                                } else {
                                    // Only draw if point is reasonable (not a huge jump)
                                    if (lastValidPoint) {
                                        const dx = xO - lastValidPoint.x;
                                        const dy = yO - lastValidPoint.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < EARTH_RADIUS * 10) { // Reasonable step size
                                            ctx.lineTo(xO, yO);
                                            lastValidPoint = { x: xO, y: yO };
                                        }
                                    } else {
                                        ctx.lineTo(xO, yO);
                                        lastValidPoint = { x: xO, y: yO };
                                    }
                                }
                            }
                        }
                    }
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                    ctx.lineWidth = Math.max(metersPerPixel * 3, 2);
                    ctx.setLineDash([metersPerPixel * 20, metersPerPixel * 10]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.restore(); // Restore coordinate transform
            ctx.restore();
            
            // Info
            ctx.fillStyle = '#555';
            ctx.font = '11px Courier New';
            ctx.fillText(`${metersPerPixel < 1000 ? metersPerPixel.toFixed(1) + ' m/px' : (metersPerPixel/1000).toFixed(2) + ' km/px'}`, 10, canvas.height - 10);
        }
        
        let lastTime = 0;
        function loop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            update(dt);
            render();
            requestAnimationFrame(loop);
        }
        
        document.getElementById('launch-btn').addEventListener('click', () => {
            if (!state.running && state.time === 0) {
                state.running = true;
                state.engineOn = true;
                addEvent("LIFTOFF!");
                document.getElementById('launch-btn').disabled = true;
                document.getElementById('launch-btn').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'inline-block';
            }
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            if (state.running) {
                state.running = false;
                document.getElementById('pause-btn').textContent = 'RESUME';
                addEvent("PAUSED");
            } else {
                state.running = true;
                document.getElementById('pause-btn').textContent = 'PAUSE';
                addEvent("RESUMED");
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            initState();
            document.getElementById('launch-btn').disabled = false;
            document.getElementById('launch-btn').style.display = 'inline-block';
            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('pause-btn').textContent = 'PAUSE';
            updateTelemetry();
        });
        
        const speeds = [1, 2, 5, 10, 25, 50, 100, 500, 1000];
        let speedIdx = 0;
        document.getElementById('speed-btn').addEventListener('click', () => {
            speedIdx = (speedIdx + 1) % speeds.length;
            state.timeWarp = speeds[speedIdx];
            document.getElementById('speed-btn').textContent = speeds[speedIdx] + 'x';
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', () => {
            state.manualZoom /= 2.0;
            if (state.manualZoom < 0.1) state.manualZoom = 0.1;
        });
        
        document.getElementById('zoom-in-btn').addEventListener('click', () => {
            state.manualZoom *= 2.0;
            // No upper bound when centered on Earth
            if (state.cameraMode === 'rocket' && state.manualZoom > 10000) state.manualZoom = 10000;
        });
        
        document.getElementById('zoom-auto-btn').addEventListener('click', () => {
            state.autoZoom = !state.autoZoom;
            document.getElementById('zoom-auto-btn').textContent = state.autoZoom ? 'AUTO ZOOM' : 'MANUAL ZOOM';
            if (!state.autoZoom) {
                state.manualZoom = 1.0; // Reset manual zoom when switching to auto
            }
        });
        
        document.getElementById('camera-btn').addEventListener('click', () => {
            state.cameraMode = state.cameraMode === 'rocket' ? 'earth' : 'rocket';
            document.getElementById('camera-btn').textContent = state.cameraMode === 'rocket' ? 'FOLLOW ROCKET' : 'CENTER EARTH';
            // Reset zoom to reasonable default when switching to Earth mode
            if (state.cameraMode === 'earth') {
                state.manualZoom = 1.0;
                state.autoZoom = false; // Disable auto zoom in Earth mode
            }
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Scroll down (deltaY > 0) should zoom out, scroll up (deltaY < 0) should zoom in
            const zoomFactor = e.deltaY > 0 ? 1/1.3 : 1.3;
            state.manualZoom *= zoomFactor;
            if (state.manualZoom < 0.1) state.manualZoom = 0.1;
            // No upper bound when centered on Earth
            if (state.cameraMode === 'rocket' && state.manualZoom > 10000) state.manualZoom = 10000;
        });
        
        // Burn control buttons - hold to burn
        let activeBurnButton = null;
        
        function stopBurn() {
            if (state.burnMode && state.burnStartTime !== null) {
                const burnNames = {
                    'prograde': 'PROGRADE',
                    'retrograde': 'RETROGRADE',
                    'normal': 'NORMAL',
                    'anti-normal': 'ANTI-NORMAL',
                    'radial': 'RADIAL',
                    'anti-radial': 'ANTI-RADIAL'
                };
                const duration = (state.time - state.burnStartTime).toFixed(1);
                addEvent(`${burnNames[state.burnMode]} burn ended (${duration}s)`);
                state.burnMode = null;
                state.burnStartTime = null;
                state.engineOn = false; // Turn off engine when burn ends
                activeBurnButton = null;
            }
        }
        
        function setupBurnButton(buttonId, burnMode) {
            const btn = document.getElementById(buttonId);
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const pitchProgramComplete = state.time > 600 || (!state.engineOn && getAltitude() > 150000);
                if (pitchProgramComplete && getAltitude() > 150000) {
                    // Stop any existing burn
                    if (state.burnMode) {
                        stopBurn();
                    }
                    state.burnMode = burnMode;
                    state.burnStartTime = state.time;
                    activeBurnButton = btn;
                    addEvent(`${burnMode.toUpperCase()} burn started`);
                }
            });
            btn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                if (state.burnMode === burnMode) {
                    stopBurn();
                }
            });
            btn.addEventListener('mouseleave', () => {
                if (state.burnMode === burnMode && activeBurnButton === btn) {
                    stopBurn();
                }
            });
        }
        
        // Global mouseup listener to catch mouse release anywhere
        document.addEventListener('mouseup', () => {
            if (state.burnMode && activeBurnButton) {
                stopBurn();
            }
        });
        
        setupBurnButton('burn-prograde-btn', 'prograde');
        setupBurnButton('burn-retrograde-btn', 'retrograde');
        setupBurnButton('burn-normal-btn', 'normal');
        setupBurnButton('burn-anti-normal-btn', 'anti-normal');
        setupBurnButton('burn-radial-btn', 'radial');
        setupBurnButton('burn-anti-radial-btn', 'anti-radial');
        
        // Refuel button - adds propellant for orbital maneuvers
        document.getElementById('refuel-btn').addEventListener('click', () => {
            if (state.currentStage < ROCKET_CONFIG.stages.length) {
                const refuelAmount = 5000; // kg
                state.propellantRemaining[state.currentStage] += refuelAmount;
                // Cap at original propellant mass
                if (state.propellantRemaining[state.currentStage] > ROCKET_CONFIG.stages[state.currentStage].propellantMass) {
                    state.propellantRemaining[state.currentStage] = ROCKET_CONFIG.stages[state.currentStage].propellantMass;
                }
                addEvent(`Refueled: +${refuelAmount} kg propellant`);
            }
        });
        
        initState();
        updateTelemetry();
        requestAnimationFrame(loop);
    </script>
</body>
</html>